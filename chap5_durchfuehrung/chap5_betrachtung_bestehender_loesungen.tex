\section{Betrachtung bestehender Lösungen}
In diesem Abschnitt erfolgt eine Untersuchung des aktuellen Stands der Technik im Bereich der hardwarenahen Softwareentwicklung für Mikrocontroller.
Das Ziel besteht darin, gemeinsame Eigenschaften heraus zu arbeiten, verwendete Architekturmuster zu identifizieren und bestehende Ansätze und Konzepte zu analysieren, die das Problem der Treiberauswahl und -abstraktion lösen – insbesondere im Hinblick auf Portabilität und Wiederverwendbarkeit. 

Die Analyse dient zudem der Identifikation möglicher Lücken oder Einschränkungen bestehender Lösungen und trägt somit zur Begründung der Relevanz und Zielsetzung dieser Arbeit bei.

Im Rahmen der Untersuchung wurden neben Onlinerecherchen speziell praxisnahe Quellen herangezogen. 
Zu den praxisnahen Quellen zählen technische Dokumentationen, Open-Source-Projekte und Herstellerdokumentationen.
Der Fokus der Recherche lag auf bestehenden Lösungen für die plattformübergreifende Auswahl von Hardwaretreibern für Mikrocontroller.
Die im Rahmen der Untersuchung verwendeten relevanten Schlüsselbegriffe umfassten unter anderem \textit{Hardware Abstraction Layer, Embedded Driver Portability, STM32, ESP32, CMSIS, Arduino Core, Zephyr RTOS,C++ Hardware API Design}.

Auf diese Weise wurden verschiedene Ansätze zur Hardwareabstraktion und Treiberbereitstellung gefunden.
Die \emph{Common Microcontroller Software Interface Standard} (CMSIS)-Bibliothek ist eine von ARM entwickelte Schnittstelle, die eine weit verbreitete Anwendung findet. 
Sie bietet eine einheitliche Zugriffsebene für Cortex-M-Prozessoren. 
Herstellerbezogene Entwicklungsumgebungen wie die STM32CubeIDE von STMicroelectronics und die Espressif-IDE bieten umfangreiche Hardware-Abstraktionsbibliotheken, die gezielt auf ihre jeweiligen Mikrocontroller-Familien zugeschnitten sind.

Darüber hinaus wurden zwei Open-Source-Projekte auf GitHub analysiert: mcu-cpp und modm. 
Die Zielsetzung beider Ansätze besteht in der Modularisierung der Treiberentwicklung in C++ sowie der Bereitstellung portabler, wiederverwendbarer Hardware-APIs. 
Die Projekte zeigen eine Reihe unterschiedlicher Herangehensweisen in Bezug auf Abstraktionslevel, Architektur und Hardwareunterstützung, was wertvolle Erkenntnisse für die eigene Lösungsentwicklung bietet.
\\
\\
In den folgenden Absätzen werden die einzelnen Plattformen bewertet und potentiellen Vor- und Nachteile benannt; auch in Bezug auf die Anforderungen der eigenen Lösung. 
%Wie machen das andere; auch in Form kommerzieller Werkzeuge (cubeIDE, Espressif):
%\begin{itemize}
% 	\item CMSIS
%	\item Espressif IDE
%\end{itemize}


\subsection{STM32Cube}
\input{chap5_durchfuehrung/chap5_2/stm32.tex}

\subsection{Espressif-IDF}
% TODO: chap4 Espressif-IDE
\input{chap5_durchfuehrung/chap5_2/esp32.tex}

% TODO: chap4 mcu-cpp & modm: Tiefer Analyse: Wie ist der Code aufgebaut -> Architektur-Muster

\subsection{mcu-cpp}
\input{chap5_durchfuehrung/chap5_2/mcu_cpp.tex}
% TODO: chap4 mcu-cpp: Quellen-Verlinkung


\subsection{modm}
\input{chap5_durchfuehrung/chap5_2/modm.tex}

























