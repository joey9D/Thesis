%Die Entwicklung einer benutzerfreundlichen und leistungsfähigen API-Library erfordert eine systematische Herangehensweise, die die einzelnen Phasen der Anforderungsanalyse, Architekturentwurf, Implementierung, Testing und Dokumentation integriert.
 
In diesem Teil der Arbeit wird ein Konzept der API erstellt.
Der Aufbau dieses Konzepts passiert in mehreren Schritten:
\begin{itemize}
	\item [1.] Anforderungsanalyse: \\In diesem Abschnitt werden die wichtigen Eigenschaften, die die API haben muss zusammengetragen. Daneben wird analysiert, wie die Funktionen, die enthalten sein sollen aufgebaut und implementiert werden können.
	\item [2.] Architekturentwurf: \\Hier werden Architekturmuster für das gesamte System der API und Designmuster für mögliche Module ausgewählt.
\end{itemize}

Anhand dieses Entwurfs wird ein neue Zwischenschicht implementiert.
%Die Zwischenschicht wählt zur Kompilierzeit die richtige Hardware aus, damit das nicht zur Runtime geschehen muss (da dies Performanceeinbusen mit sich bringen würde) und bekommt so die richtigen Treiber mit.
%Die Zwischenschicht soll eine Art Default-Klasse für die jeweilige Funktion bereitstellen.
%Mit der ausgewählten Hardware können die Default-Klassen die richtigen Treiber ansprechen.

\section{Anforderungsanalyse}
Um eine benutzerfreundlichen und leistungsfähigen API-Bibliothek entwickeln zu können, ist es wichtig die grundlegenden Funktionen klar zu definieren.
So gilt es als erstes die Fragen zu klären: \emph{Was muss die API können?} und \emph{Welche Eigenschaften soll die API haben?}

Es ist das übergeordnete Ziel, plattformunabhängigen Code schreiben zu können.
Das bedeutet, es muss möglich sein ein Programm, das z.B. für eine Hardware mit einem STM32-MCU geschrieben wurde, auch für Hardware mit einer ESP32-MCU funktionsfähig zu haben.
Die spezifische Konfiguration der Hardware und der Pins, wie sie beispielsweise mit STM32CubeMX gemacht werden kann, muss dennoch für jede Hardware, je nach Projekt, neu erstellt werden.
Dies liegt unter anderem an den unterschiedlichen Prozessorarchitekturen, der Anzahl an Pins und deren Zuordnung zu spezifischen Funktionen oder der Registerkonfiguration.
Um eine Pinkonfiguration mit Code zu lösen und von der graphischen Oberfläche wegzukommen, liegt der Gedanke, Objekte zu verwenden nahe.
Besonders im Kontext der Verwendung von C++.
Solche Objekt werden mittels eines Konstruktors, der die Werte für die Attribute der Pins übergeben bekommt, erstellt.
Bevor eine Erstellung dieser Pin-Objekte stattfinden kann, Aufgrund der angesprochen Unterschiede, muss erst die Hardware ausgewählt werden.

Damit die Pin-Objekte auch verwendet werden können, muss vorher die Hardware ausgewählt und initialisiert werden.
Beginnend mit der Auswahl, muss die API in der Lage sein nach einer Art der Definition, welche Hardware real zur Verfügung steht, die passenden Treiber auszuwählen, eine Instanz der Hardware zu erstellen, mit der im Programm gearbeitet werden kann und aus diesem heraus die Hardware über allgemein definierte Funktionen mit den richtigen Treibern zu initialisieren.
Diese Definition kann beispielsweise über ein \texttt{\#define}, dass den Namen der Hardware beinhaltet gelöst werden.
Mit Blick auf zukünftige Veränderungen sollte es auch so einfach wie möglich sein, weitere Hardware der API hinzu zu fügen, um die Auswahl zu erweitern.
Diese Veränderungen und Erweiterungen würden auch die jeweiligen Peripheriefunktionen betreffen.
Um einen klaren Überblick über diese Funktionen zu behalten, ist der Gedanke an Module zu betrachten.
So könnte für jede Peripheriefunktion (\gls{gpio}, \gls{spi}, \gls{uart}, \gls{can}) ein eigenes Modul implementiert werden.
Auf diese Weise hat man neben dem Überblick auch eine klare Struktur, die Fehlersuchen und Wartungen der Software wiederum vereinfacht.



\section{Architekturentwurf}

\begin{itemize}
%	\item Was muss die API können?
	\item Welche Grundarchitektur liegt vor?
	\item Welches Architekturmuster eignet sich dafür?
	\item Welche Architektur eignet sich hier für? $\rightarrow$ Aufbau des gesamten Systems
	\item Desgin Patterns $\rightarrow$ Aufbau der einzelnen Klassen
	\begin{itemize}
		\item Welche werden sonst eingesetzt; welches eignet sich für diesen Zweck
		\item Wie sollen die Module der jeweiligen Peripherie aufgebaut sein?
	\end{itemize}
	\item C++ $\rightarrow$ Objekt-orientiert
	\item Erstellung von Objekten?
	\item Auswahl der Funktionen
	\item 
\end{itemize}

\begin{itemize}
	\item Globales Interface
	\item Factory Architektur zur Erstellung von Objekten
	\item Peripheriefunktionen (GPIO, SPI, etc.) als eigenständigen Klassen
%	\item Verwendung von \texttt{namespaces}
	\item HardwareInterface mit allen:
	\begin{itemize}
		\item vllt. Core: ClockInit, Delay, GetTick
		\item Gpio
		\item SPI
		\item UART
		\item CAN
	\end{itemize}
	\item Interface ruft Factory auf, die MCU spezifischen Treiber inkludiert und eine Instanz des HW-Objektes zurückgibt. Mit dieser kann gearbeitet werden.
	\item 
\end{itemize}


%\section{Einstellungen pro MCU}

%TODO: informations in reference manual for each mcu
% CONFIG Abschnitt im cmake
%\begin{lstlisting}
%add_compile_options(
%	-mcpu=
%	-mfloat-abi=
%	-mfpu=
%	-mthumb
%	-ffunction-sections
%	-fdata-sections
%	$<$<COMPILE_LANGUAGE:CXX>:-fno-exceptions>
%	$<$<COMPILE_LANGUAGE:CXX>:-fno-rtti>
%	$<$<COMPILE_LANGUAGE:CXX>:-fno-threadsafe-statics>
%	$<$<COMPILE_LANGUAGE:CXX>:-fno-use-cxa-atexit>
%)
%\end{lstlisting}



\section{Architektonische Eigenschaften der Treiber-API}
Moderen Softwarelösungen bestehen meist aus vielen, großen Dateien, die untereinander von einander abhängig sind.
Um bei solch großen Projekten den Überblick zu behalten, werden/sollten diese Softwarelösungen nach gewissen Eigenschaften erstellt werden.
Diese \emph{architektonischen Eigenschaften} lassen sich (grob) in drei Teilbereiche unterteilen: Betriebsrelevante, Strukturelle und Bereichsübergreifende, wie in Tabelle~\ref{tab:architektonische_eigenschaften} aufgeführt. % Eigenschaften. 

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c | c }
			\textbf{Betriebsrelevante} & \textbf{Strukturelle} & \textbf{Bereichsübergreifende}\\
			%\midrule
			\hline
			Verfügbarkeit & Erweiterbarkeit & Sicherheit\\
			Performance & Modularität & Rechtliches\\
			Skalierbarkeit & Wartbarkeit & Usability\\
			$\cdots$ & $\cdots$ & $\cdots$\\
		\end{tabular}
		\caption{Teilbereiche architektonischer Eigenschaften}
	    \label{tab:architektonische_eigenschaften}
	\end{center}
\end{table}

Aus diesen Eigenschaften gilt es, die wichtigsten für die Treiber-API zu identifizieren. 
Mit diesem Hintergrund lässt sich ein Struktur für das Projekt bilden.

Die Entwicklung einer plattformunabhängigen, wiederverwendbaren Treiber-API für Mikro-controller stellt hohe Anforderungen an die Architektur der Softwarebibliothek.

% Welche (architektonischen) Eigenschaft sind wichtig/sollen umgesetzt werden?
% geringe Redundanz
Das Ziel besteht darin, eine Lösung zu schaffen, die sich durch eine geringe Redundanz auszeichnet. 
Die Konzeption von Klassen und Funktionen sollte derart erfolgen, dass eine erneute Implementierung der Applikation für jede neue Plattform nicht erforderlich ist.
Die Wiederverwendbarkeit zentraler Komponenten führt zu einer Reduktion des Entwicklungsaufwands und einer Erhöhung der Konsistenz im Code.

% Usability - Benutzerfreundlichkeit
Ein weiteres zentrales Anliegen ist die einfache Benutzbarkeit. 
Die API ist so zu gestalten, dass eine effiziente Nutzung gewährleistet ist. 
Dies fördert nicht nur die Effizienz in der Erstellung neuer Applikationen, sondern erleichtert auch langfristig die Wartung und Weiterentwicklung der Software.

% Skalierbarkeit
Im Sinne der Skalierbarkeit wird angestrebt, die Lösung auf möglichst viele Mikrocontroller-Architekturen und Hardwareplattformen anwendbar zu machen.
Die Vielfalt verfügbarer MCUs erfordert eine abstrahierte und flexibel erweiterbare Struktur, die die Integration neuer Plattformen mit minimalem Aufwand ermöglicht.

% Portabilität - nochmal anpassen; OS Bezug passt nicht richtig
Auch die Portabilität spielt eine wichtige Rolle.
Die Bibliothek sollte nicht nur hardware-, sondern auch betriebssystemunabhängig konzipiert werden.
Aus diesem Grund wird bei der Entwicklung der Lösung darauf geachtet, dass diese erst unter Windows, später auch unter Linux und macOS einsetzbar ist.
Die Installation und Konfiguration der dafür benötigten Werkzeuge wird nachvollziehbar dokumentiert, um den Einstieg für die Nutzer zu erleichtern.

% Erweiterbarkeit
Darüber hinaus ist die Erweiterbarkeit ein wesentliches Architekturprinzip
Der Einsatz von leistungsstärkeren Mikrocontrollern hängt in der Regel mit einer Erweiterung der Funktionalitäten zusammen, die in die bestehenden Treiber- und API-Strukturen integriert werden müssen.
Daher wird großer Wert auf eine modulare und offen gestaltete Architektur gelegt, die neue Features ohne grundlegende Umbauten aufnehmen kann.

% Modularität
Modularität trägt wesentlich zur Übersichtlichkeit und Wartbarkeit des Systems bei. 
Eine saubere Trennung funktionaler Einheiten ermöglicht eine schnellere Lokalisierung und Behebung von Fehlern, was wiederum die langfristige Pflege und Weiterentwicklung der Software erleichtert.

% (Ressourcen-)Effizienz
Schließlich ist auch die Effizienz ein kritischer Aspekt.
Da Mikrocontroller in der Regel nur über begrenzte Ressourcen verfügen, ist es essenziell, dass die Bibliothek möglichst kompakt und ressourcenschonend implementiert wird. 
Externe Abhängigkeiten werden bewusst auf ein Minimum reduziert, um Speicherplatz zu sparen und unnötige Komplexität zu vermeiden.

Diese architektonischen Prinzipien bilden die Grundlage für die Konzeption und Umsetzung der in dieser Arbeit vorgestellten Treiber-API.

% Fragen
Wie wird der jeweilige Punkt umgesetzt?

Welche Tools werden benutzt/eignen sich besonders für die Umsetzung?
Welche Tools eignen sich für welchen Arbeitsschritt?

Warum wird etwas gerade auf diese Weise umgesetzt?





























