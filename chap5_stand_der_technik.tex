In diesem Kapitel wird der aktuelle Stand der techwerden alternative Lösungen recherchiert und untersucht.
Ziel ist die Analyse bestehender Erkenntnisse und Theorien sowie die Identifizierung von Forschungslücken, die die Relevanz der vorliegenden Arbeit begründen.
Es wird geschaut, welche Ansätze verwendet werden, wie weit diese Ansätze den Anforderungen der eigenen Lösung entsprechen und ob diese in der eigenen Umsetzung der Lösung helfen.



\section{Recherche}
Welche Lösungen gibt es bereits?
Wie machen das andere; auch in Form kommerzieller Werkzeuge (cubeIDE, Espressif):
\begin{itemize}
	\item stm32CubeIDE
	\item Espressif IDE
	\item mcu-cpp
	\item modm
\end{itemize}

\section{Bewertung der Alternativlösungen}
\subsection{STM32CubeIDE}
Prozess via UI ermöglicht:
\begin{itemize}
	\item Auswahl der Hardware
	\item Konfiguration der Pins
\end{itemize}

Sobald die Konfiguration und das Projekt das erste mal bestätigt wird, werden die entsprechenden Treiber (CMSIS und HAL) automatisch mit heruntergeladen und dem Projekt hinzugefügt.
+ Funktioniert für alle STM32 MCUs
- \textbf{nur} für STM32 MCUs

Für allgemeine Projekte bzw. st-fremde Hardware besteht die Möglichkeit, leere CMake-Projekte erstellt werden.
Hier müssen die benötigten Pakete und Treiber selber inkludiert werden; die Build-Befehle müssen selber in eigenen CMakeLists.txt Dateien implementiert werden.

Für zukünftigen Einsatz von Zephyr


\subsectionm{Espressif-IDE}


\subsection{mcu-cpp}
Pro:
Interface-/virtuelle Klasse, die als Basis dienen.

Verwendung von eigenen \texttt{namespaces} $\rightarrow$ sorgt für klaren, lesbaren Code in der Implementierung von Anwendungen.

Aktuelle wird FreeRTOS verwendet; in Zukunft sollte dies durch Zephyr ersetzt werden.
Da FreeRTOS aber stark in den bisherigen Code integriert ist, wär dieser Wechsel erneut mit erhöhtem Aufwand verbunden.



Con:
Keine Verwendung der existierenden Treiber $\rightarrow$ z.b. HAL; statt dessen selbst geschriebene Treiber bzw. Wrapperklassen.

Führt dazu, dass für jede neue Hardware eine neue Wrapper geschrieben werden muss, was den Anfordungen widerspricht.

\subsection{modm}
Codegenerierung via .in-Dateien.

Bevor mit der Implementierung den Applikation begonnen werden kann, muss die Hardware ausgewählt werden.
Dieses Projekt macht das, indem es der Prozess im Terminal gestartet wird.
Nachdem die MCU ausgewählt wurde, kann und müssen alle Funktionen ausgewählt werden, die mit benutzt werden sollen.
D.h. wenn die GPIO-Pins in der Applikation verwendet werden sollen, müssen diese auch im Konfigurationsprozess ausgewählt werden; und so auch alle weiteren Funktionen.
Sobald man alles ausgewählt hat, beginnt der Installations- bzw. der Generierungsprozess der Library. 
Hierbei werden alle Treiber der ausgewählten Funktionen erstellt; sodass man diese dann in seiner Anwendungsimplementierung verwenden kann.


\section{Abgrenzung des eigenen Ansatzes}



