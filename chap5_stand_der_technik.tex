In diesem Kapitel erfolgt eine Untersuchung des aktuellen Stands der Technik im Bereich der hardwarenahen Softwareentwicklung für Mikrocontroller.
Das Ziel besteht darin, bestehende Ansätze und Konzepte zu analysieren, die das Problem der Treiberauswahl und -abstraktion lösen – insbesondere im Hinblick auf Portabilität und Wiederverwendbarkeit. 
In der vorliegenden Untersuchung wird eine Analyse der gegenwärtig in der Praxis und Forschung eingesetzten Methoden vorgenommen. 
Ziel dieser Analyse ist es, die Übereinstimmung dieser Ansätze mit den Anforderungen der jeweiligen Zielsetzung zu ermitteln und deren Eignung für die Umsetzung einer eigenen Lösung zu evaluieren.

Die Analyse dient zudem der Identifikation möglicher Lücken oder Einschränkungen bestehender Lösungen und trägt somit zur Begründung der Relevanz und Zielsetzung dieser Arbeit bei.


\section{Recherche}
Im Rahmen der Untersuchung wurden sowohl wissenschaftliche Publikationen als auch praxisnahe Quellen herangezogen. 
Zu den praxisnahen Quellen zählen technische Dokumentationen, Open-Source-Projekte und Herstellerdokumentationen.
Der Fokus der Recherche lag auf bestehenden Lösungen für die plattformübergreifende Entwicklung von Hardwaretreibern für Mikrocontroller.
Die im Rahmen der Untersuchung verwendeten relevanten Schlüsselbegriffe umfassten unter anderem \textit{Hardware Abstraction Layer, Embedded Driver Portability, CMSIS, Arduino Core, Zephyr RTOS,C++ Hardware API Design}.

Auf diese Weise wurden verschiedene Ansätze zur Hardwareabstraktion und Treiberbereitstellung gefunden.
Die \emph{Common Microcontroller Software Interface Standard} (CMSIS)-Bibliothek ist eine von ARM entwickelte Schnittstelle, die eine weit verbreitete Anwendung findet. 
Sie bietet eine einheitliche Zugriffsebene für Cortex-M-Prozessoren. 
Herstellerbezogene Entwicklungsumgebungen wie die STM32CubeIDE von STMicroelectronics und die Espressif-IDE bieten umfangreiche Hardware-Abstraktionsbibliotheken, die gezielt auf ihre jeweiligen Mikrocontroller-Familien zugeschnitten sind.

Darüber hinaus wurden zwei Open-Source-Projekte auf GitHub analysiert: mcu-cpp und modm. 
Die Zielsetzung beider Ansätze besteht in der Modularisierung der Treiberentwicklung in C++ sowie der Bereitstellung portabler, wiederverwendbarer Hardware-APIs. 
Die Projekte zeigen eine Reihe unterschiedlicher Herangehensweisen in Bezug auf Abstraktionslevel, Architektur und Hardwareunterstützung, was wertvolle Erkenntnisse für die eigene Lösungsentwicklung bietet.
\\
\\
In den folgenden Absätzen werden die einzelnen Plattformen bewertet und potentiellen Vor- und Nachteile benannt; auch in Bezug auf die Anforderungen der eigenen Lösung. 
%Wie machen das andere; auch in Form kommerzieller Werkzeuge (cubeIDE, Espressif):
%\begin{itemize}
% 	\item CMSIS
%	\item stm32CubeIDE
%	\item Espressif IDE
%	\item mcu-cpp
%	\item modm
%\end{itemize}

\section{Bewertung der Alternativlösungen}
\subsection{STM32CubeIDE}
Prozess via UI ermöglicht:
\begin{itemize}
	\item Auswahl der Hardware
	\item Konfiguration der Pins
\end{itemize}

Sobald die Konfiguration und das Projekt das erste mal bestätigt wird, werden die entsprechenden Treiber (CMSIS und HAL) automatisch mit heruntergeladen und dem Projekt hinzugefügt.
+ Funktioniert für alle STM32 MCUs
- \textbf{nur} für STM32 MCUs

Für allgemeine Projekte bzw. st-fremde Hardware besteht die Möglichkeit, leere CMake-Projekte erstellt werden.
Hier müssen die benötigten Pakete und Treiber selber inkludiert werden; die Build-Befehle müssen selber in eigenen CMakeLists.txt Dateien implementiert werden.

Für zukünftigen Einsatz von Zephyr


\subsection{Espressif-IDE}


\subsection{mcu-cpp}
% TODO: chap5 mcu-cpp: Quellen-Verlinkung
Das Projekt \emph{mcu-cpp} verwendet einen eigenen \texttt{namespace} um die einzelnen Funktionen und Klassen zu gruppieren.
\emph{Namespaces} sind eine Möglichkeit in C++ um Variablen, Klasse und Funktionen zu gruppieren, damit Konflikte bei der Benennung solcher Identifizierer zu vermeiden.
Die ermöglicht einen sauber-strukturierten und lesbaren Applikationscode zu schreiben, in dem man nachvollziehen kann, wer was aufruft.
Basierend auf den virtuellen Klassen, implementieren die jeweiligen MCUs die Methoden damit diese für sich funktionieren.
Damit innerhalb einer Produktfamilie, z.B. STM32F0 MCUs, die richtigen bzw. alle notwendigen Ports aktiviert werden, gibt es eine zusätzliche Datei \texttt{gpio\_hw\_mapping.hpp}.
In dieser werden einzelne Ports, die nicht auf jeder MCU verfügbar sind, durch bedingte Kompilierung aktiviert oder nicht.
Die Information, welche Hardware verwendet wird, muss entweder in der \texttt{CMakeLists.txt} oder im Code mit \texttt{\#define} angegeben sein.
\\
\\
Pro:
Interface-/virtuelle Klasse, die als Basis dienen.


Aktuelle wird FreeRTOS verwendet; in Zukunft sollte dies durch Zephyr ersetzt werden.
Da FreeRTOS aber stark in den bisherigen Code integriert ist, wär dieser Wechsel erneut mit erhöhtem Aufwand verbunden.
\\
\\
Con:
Keine Verwendung der existierenden Treiber $\rightarrow$ z.b. HAL; statt dessen selbst geschriebene Treiber bzw. Wrapperklassen.

Führt dazu, dass für jede neue Hardware eine neue Wrapper geschrieben werden muss, was den Anfordungen widerspricht.

\subsection{modm}
Codegenerierung via .in-Dateien.

Bevor mit der Implementierung den Applikation begonnen werden kann, muss die Hardware ausgewählt werden.
Dieses Projekt macht das, indem es der Prozess im Terminal gestartet wird.
Nachdem die MCU ausgewählt wurde, kann und müssen alle Funktionen ausgewählt werden, die mit benutzt werden sollen.
D.h. wenn die GPIO-Pins in der Applikation verwendet werden sollen, müssen diese auch im Konfigurationsprozess ausgewählt werden; und so auch alle weiteren Funktionen.
Sobald man alles ausgewählt hat, beginnt der Installations- bzw. der Generierungsprozess der Library. 
Hierbei werden alle Treiber der ausgewählten Funktionen erstellt; sodass man diese dann in seiner Anwendungsimplementierung verwenden kann.

Pro:
Auf diese Weise bestehen die Treiber-Libraries nur aus den Funktionen, die man tatsächlich braucht, ohne unnötigen Überhang.

Con:
Mit diesem Verfahren wird die zukünftige Integration eines RTOS wie Zephyr sehr schwierig.

\section{Abgrenzung des eigenen Ansatzes}
Ähnlich zu dem Projekt mcu-cpp soll die eigene Lösung auch Interfaces bzw. virtuelle Klassen als Basis verwenden, die dann von allen MCUs abstrahiert werden können.
Auf diese Weise bekommt jede MCU eine eigene Kindklasse, über die die richtigen Treiber ausgewählt werden.










