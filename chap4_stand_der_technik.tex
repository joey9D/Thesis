
Unter Portabilität von Software in eingebetteten Systemen wird im Kontext dieser Arbeit die Fähigkeit verstanden, einmal entwickelten Quellcode mit möglichst geringem Anpassungsaufwand auf unterschiedliche Mikrocontrollerarchitekturen und Hardwareplattformen zu übertragen. 
Dieses Ziel besitzt insbesondere im Hinblick auf die potenziellen Änderungen der Hardwareanforderungen im Produktlebenszyklus eine hohe Relevanz, da es zu einer Migration auf alternative Controllerfamilien kommen kann.
Von zentraler Bedeutung sind hierbei die Auswahl geeigneter Treiber sowie die Abstraktionsebene der Hardwarezugriffe, die die Entkopplung zwischen Anwendungscode und konkreter Zielhardware bestimmen.

In der Praxis existieren verschiedene Ansätze, die versuchen, mit jeweils eigene Stärken und Einschränkungen, dieses Problem zu lösen.

\section{Lightweight Operation Systems}
Die Abstraktion von Hardwarefunktionen kann durch den Einsatz schlanker Betriebssysteme wie FreeRTOS, Zephyr oder RIOT-OS erfolgen. 
Diese bieten einheitliche Schnittstellen für Multitasking, Synchronisation und Peripheriezugriffe und erleichtern dadurch die Übertragbarkeit von Anwendungen zwischen unterschiedlichen Mikrocontrollerarchitekturen. 
Gleichzeitig verursachen sie jedoch einen zusätzlichen Ressourcenverbrauch, der auf sehr leistungslimitierten Controllern problematisch sein kann.
 Darüber hinaus ist anzumerken, dass die Abhängigkeit von den jeweiligen Hardwareabstraktionsschichten (\gls{hal}) bestehen bleibt, sodass eine vollständige Unabhängigkeit von der Zielhardware nicht erreicht wird. \cite{freertos}\cite{zephyr}\cite{riot}.  


\section{Retargetierbare Compiler}
Ein alternativer Ansatz besteht im Einsatz retargetierbarer Compiler. 
Die Verwendung von Systemen wie GCC oder LLVM erlaubt die Übertragung identischer Quellcodes auf unterschiedliche Zielarchitekturen, wobei lediglich das Backend an die spezifische Plattform angepasst wird.
Dadurch wird eine hohe Flexibilität auf der Ebene der Codegenerierung gewährleistet. 
Allerdings erfolgt keine Abstraktion der hardwarenahen Zugriffe.
Die Funktion \texttt{HAL\_GPIO\_WritePin()} wie bei STM32 verwendet wird, kann somit nicht für ESP32 verwendet werden.
Hier kommt die Funktion \texttt{gpio\_set\_level()} zum Einsatz.
Ein retargetierbarer Compiler allein kann diese Unterschiede nicht kompensieren. 
Peripheriezugriffe und Registerkonfigurationen bleiben plattformspezifisch, sodass diese für jeden Mikrocontroller individuell implementiert werden müssen. 
Ohne eine zusätzliche Abstraktionsschicht muss der Quellcode für jede Plattform individuell angepasst werden.\cite{gccint}\cite{llvm}\cite{johnson1975}

\section{Arduino-Framework}
Das Arduino-Ökosystem zeichnet sich durch einen pragmatischen, anwendungsorientierten Ansatz aus.
Ursprünglich für AVR-Mikrocontroller konzipiert, existieren heute Erweiterungen sowohl für STM32- als auch für ESP32-Micorcontroller. 
Die Entwicklung und Portierung wird durch die Verwendung einer einheitlichen und stark vereinfachten API erleichtert, die die Hardwarezugriffe abstrahiert. 
Dadurch lassen sich schnelle Prototypen erstellen. 
Dieser Ansatz hat sich insbesondere in der Maker-Community etabliert, weist jedoch im industriellen Umfeld gewisse Einschränkungen auf. 
Die Abstraktionsebene weist eine vergleichsweise geringe Detailtiefe auf, die Effizienz ist in nicht allen Szenarien ausreichend und Aspekte wie Modularität oder langfristige Wartbarkeit sind nur eingeschränkt gewährleistet.\cite{stm32duino}\cite{arduinoesp32}. 

\vspace{0.5em}
\noindent\rule{\linewidth}{0.4pt}
\vspace{0.5em}

Die zuvor genannten Ansätze verdeutlichen, dass die Frage der Portabilität stets mit einem Konflikt zwischen Ressourcenverbrauch, Abstraktionsgrad und Wartbarkeit verbunden ist. 
Obwohl Betriebssysteme und Compiler vorrangig die Entwicklungsumgebung standardisieren und Arduino durch eine vereinfachte High-Level-API arbeitet, sind auch diese etablierten Ansätze nicht frei von Einschränkungen. 
In Anbetracht dessen verfolgt die vorliegende Arbeit einen alternativen Ansatz. 
Der Fokus liegt auf der Entwicklung einer modularen, ressourcenschonenden und plattformunabhängigen Treiberbibliothek in C++. 
Im Gegensatz zu Light OS erfolgt keine vollständige Einführung eines Betriebssystems, wodurch der Ressourcenverbrauch minimiert bleibt. 
Im Zuge dessen wird gegenüber Compiler-basierten Lösungen eine klare Abstraktionsebene geschaffen, die hardwarespezifische Implementierungen kapselt.
Im Unterschied zum Arduino-Framework liegt der Fokus nicht auf einer vereinfachten, sondern auf einer wohldefinierten und erweiterbaren Schnittstelle, die eine langfristige Softwarebasis für den industriellen Einsatz ermöglicht.