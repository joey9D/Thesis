\section{Problemstellung}
Mikrocontroller unterscheiden sich in vielerlei Hinsicht, unter anderem in ihrer Architektur, der verfügbaren Peripherie, dem Befehlssatz sowie in der Art und Weise, wie ihre Hardwarekomponenten über Register angesteuert werden.
Die Aufgabe dieser Register besteht in der Konfiguration und Steuerung grundlegender Funktionen, wie etwa der digitalen Ein- und Ausgänge, der Taktung, der Kommunikationsschnittstellen oder der Interrupt-Verwaltung.
Die konkrete Implementierung sowie die Adressierung und Bedeutung einzelner Bits und Bitfelder variieren jedoch von Hersteller zu Hersteller und sogar zwischen verschiedenen Serien desselben Herstellers erheblich.

Die signifikante Varianz in Bezug auf die Hardware-Komponenten führt dazu, dass Softwarelösungen und Applikationen, für jede neue Plattform entweder vollständig neu entwickelt oder zumindest aufwendig angepasst werden müssen.
Obwohl \gls{hals} eine gewisse Erleichterung bei der Entwicklung bieten, resultieren daraus gleichzeitig starke Bindungen an die zugrunde liegende Hardwareplattform.

Die wiederholte Implementierung oder Integration plattformspezifischer Klassen, Module und Bibliotheken erfordert einen erheblichen Aufwand in Bezug auf Entwicklungszeit und Ressourcen.
Zusätzlich ist eine Zunahme an Komplexität bei der Wartung sowie eine Erschwernis bezüglich der Wiederverwendbarkeit von Softwarekomponenten über verschiedene Projekte hinweg zu beobachten.

 In Anbetracht dessen ist die Entwicklung einer abstrahierten, plattformübergreifenden Architektur erforderlich, die diese Herausforderungen adressiert und eine einheitliche, modulare Schnittstelle für die Treiberauswahl bereitstellt.



\section{Motivation}
In der Embedded-Entwicklung stellt die effiziente und wartbare Bereitstellung von Software für eine wachsende Zahl unterschiedlicher Mikrocontroller-Plattformen eine zunehmende Herausforderung dar.
Die Vielzahl verfügbarer Mikrocontroller mit unterschiedlichen Architekturen, Peripheriekomponenten und Entwicklungsumgebungen führt zu einem hohen Aufwand bei der Anpassung und Pflege von Software und Applikationen.



\section{Ablauf}
Im Kapitel Aufgabenstellung
	\begin{itemize}
		\item Klärung der genauen Aufgabenstellung,
		\item Anschauen welche Werkzeuge verwendet werden,
		\item Ab wann die Aufgabe erfüllt ist.
	\end{itemize}
	
Danach geht man über die Grundlagen
	\begin{itemize}
		\item Hardwareentwicklung
		\begin{itemize}
			\item Ports
			\item Register
			\item Funktionen
			\item . . .
		\end{itemize}
		\item 
	\end{itemize}

Mit dem Grundlagenwissen wird im nächsten Kapitel sich der aktuelle Stand der Technik angeschaut.
Dabei wird sich angeschaut welche relevanten Lösungen und Ansätze es bereits gibt und diese mit einander verglichen.
Warum sich für diesen Ansatz entschieden wurden?

Danach geht es im Hauptteil der Arbeit um die Umsetzung des API mit eigenen Anpassungen und Erweiterungen.








