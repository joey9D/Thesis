\section{Problemstellung}
% Unterschied von MCUs
Mikrocontroller unterscheiden sich in vielerlei Hinsicht, unter anderem in ihrer Architektur, der verfügbaren Peripherie, dem Befehlssatz sowie in der Art und Weise, wie ihre Hardwarekomponenten über Register angesteuert werden.
% Fokus auf Register
Die Aufgabe dieser Register besteht in der Konfiguration und Steuerung grundlegender Funktionen, wie etwa der digitalen Ein- und Ausgänge, der Taktung, der Kommunikationsschnittstellen oder der Interrupt-Verwaltung.
Die konkrete Implementierung sowie die Adressierung und Bedeutung einzelner Bits und Bitfelder variieren jedoch von Hersteller zu Hersteller und sogar zwischen verschiedenen Serien desselben Herstellers erheblich.
% Kernproblem: Neu-Implementierung von Applikationen pro Hardware
Die signifikante Varianz in Bezug auf die Hardware-Komponenten führt dazu, dass Softwarelösungen und Applikationen, für jede neue Plattform entweder vollständig neu entwickelt oder zumindest aufwendig angepasst werden müssen.
Obwohl \gls{hals} eine gewisse Erleichterung bei der Entwicklung bieten, resultieren daraus gleichzeitig starke Bindungen an die zugrunde liegende Hardwareplattform.

Die wiederholte Implementierung oder Integration plattformspezifischer Klassen, Module und Bibliotheken erfordert einen erheblichen Aufwand in Bezug auf Entwicklungszeit und Ressourcen.
Zusätzlich ist eine Zunahme an Komplexität bei der Wartung sowie eine Erschwernis bezüglich der Wiederverwendbarkeit von Softwarekomponenten über verschiedene Projekte hinweg zu beobachten.

 In Anbetracht dessen ist die Entwicklung einer abstrahierten, plattformübergreifenden Architektur erforderlich, die diese Herausforderungen adressiert und eine einheitliche, modulare Schnittstelle für die Treiberauswahl bereitstellt.



\section{Motivation}
In der Embedded-Entwicklung stellt die effiziente und wartbare Bereitstellung von Software für eine wachsende Zahl unterschiedlicher Mikrocontroller-Plattformen eine zunehmende Herausforderung dar.
Die Vielzahl verfügbarer Mikrocontroller mit unterschiedlichen Architekturen, Peripheriekomponenten und Entwicklungsumgebungen führt zu einem hohen Aufwand bei der Anpassung und Pflege von Software und Applikationen.
% TODO: Ab hier nochmal überarbeiten
In der Praxis zeigt sich, dass Softwarelösungen teils komplett neu implementiert werden müssen, wenn andere Hardware verwendet werden soll oder die Applikation auf mehreren unterschiedlichen \gls{mcus} laufen soll.
Dies führt zu redundantem Code, erschwerter Wartbarkeit und geringerer Flexibilität bei der Weiterentwicklung und Portierung von Anwendungen.
% TODO: viele MCUs pro Projekt? Nochmal Michael fragen
Gerade in Projekten, in denen verschiedene Hardwareplattformen parallel zum Einsatz kommen oder ein Wechsel der Zielplattform absehbar ist, besteht ein starkes Bedürfnis nach wiederverwendbaren und portablen Lösungen. Eine gut durchdachte Treiber-API kann hier einen entscheidenden Beitrag leisten, indem sie die Entwicklung beschleunigt, Fehler reduziert und den langfristigen Pflegeaufwand minimiert. 
 
In dieser Arbeit wird ein systematischer, praxisnaher Ansatz verfolgt, um diesen Herausforderungen zu begegnen:

Eine modulare, plattformunabhängige und ressourceneffiziente Treiberbibliothek soll die Basis für eine nachhaltige und flexible Embedded-Softwareentwicklung bilden. 


\section{Ablauf}
Im Kapitel Aufgabenstellung
	\begin{itemize}
		\item Klärung der genauen Aufgabenstellung,
		\item Anschauen welche Werkzeuge verwendet werden,
		\item Ab wann die Aufgabe erfüllt ist.
	\end{itemize}
	
Danach geht man über die Grundlagen
	\begin{itemize}
		\item Hardwareentwicklung
		\begin{itemize}
			\item Ports
			\item Register
			\item Funktionen
			\item . . .
		\end{itemize}
		\item 
	\end{itemize}

Mit dem Grundlagenwissen wird im nächsten Kapitel sich der aktuelle Stand der Technik angeschaut.
Dabei wird sich angeschaut welche relevanten Lösungen und Ansätze es bereits gibt und diese mit einander verglichen.
Warum sich für diesen Ansatz entschieden wurden?

Danach geht es im Hauptteil der Arbeit um die Umsetzung des API mit eigenen Anpassungen und Erweiterungen.








