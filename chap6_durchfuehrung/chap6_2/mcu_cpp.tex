Das Open-Source-Projekt \emph{mcu-cpp} \cite{github_mcu_cpp} verwendet einen eigenen \texttt{namespace} um die einzelnen Funktionen und Klassen zu gruppieren.
\emph{Namespaces} sind eine Möglichkeit in C++ um Variablen, Klassen und Funktionen zu gruppieren, damit Konflikte bei der Benennung solcher Identifizierer vermieden werden.
Dies ermöglicht es einen sauber-strukturierten und lesbaren Applikationscode zu schreiben, in dem man nachvollziehen kann, wer was aufruft.
Basierend auf virtuellen Klassen, werden die jeweiligen Methoden von den \gls{mcu}s implementiert.
Um innerhalb einer Produktfamilie, z.B. STM32F0 MCUs alle notwendigen Ports zu aktivieren, gibt es eine zusätzliche Datei \texttt{gpio\_hw\_mapping.hpp}.
In dieser werden einzelne Ports, die nicht auf jeder MCU verfügbar sind, durch bedingte Kompilierung zur Verfügung gestellt oder nicht.
Die Information, welche Hardware verwendet wird, muss entweder in der \texttt{CMakeLists.txt} oder im Code mit \texttt{\#define} angegeben sein.
Zusätzlich werden die CMSIS-Treiber verwendet, die die Startdateien bereit stellen.
Als RTOS ist FreeRTOS fest im Projekt integriert.
%Dies ermöglicht
Allerdings fehlen hier die offiziellen \gls{hal}-Funktionen, die bereits vorgefertigte Strukturen und Funktionen für die einzeln Hardwarefunktionen implementiert haben.
Stattdessen werden diese durch die Implementierung der virtuellen Klassen ersetzt.
Das sorgt im weiteren Verlauf dafür, dass die Funktionen auf Basis der virtuellen Klassen für jede neue MCU-Familie neu implementiert werden müssen, was für wiederholten Aufwand sorgt und den Anforderungen an die Lösung widerspricht.

Untersucht man das Projekt auf Architektur- und Designmuster lassen sich die gleichen Muster identifizieren wie bei den STM32-Projekten.
Es wird in einer Schichtenarchitektur gearbeitet.
Die Aufteilung ist nahezu identisch, mit dem Hauptprogramm in der Anwendungsschicht, der Hardwareabstraktion mit den CMSIS Dateien und neu geschriebenen Abstraktionsfunktionen, statt den klassischen \gls{hal}-Bibliothek.
Mit der Verwendung von FreeRTOS kommt hier die Middleware-Schicht, die sich zwischen der Anwendungsschicht und der Abstraktionsschicht befindet, neu hinzu.
Hierzu kann man \cref{fig:embedded_layer_architecture} noch einmal untersuchen.
% Design
Designmuster ähneln sich ebenfalls.
Für die Hardwareinitialisierung wird das Singleton verwendet.
Es gibt nur eine globale Instanz der \texttt{systick}-Klasse.
Darüber hinaus gibt es keine erkennbaren Erzeugungsmuster.
Die Auswahl der Hardware findet über die Haupt-\texttt{CMakelists.txt}-Datei statt.

Im Bereich der Strukturmuster lässt sich das Facade-Pattern erkennen.
Beispielsweise dient die Klasse \texttt{gpio\_stm32f4} der Abstraktion der Initialisierung und Steuerung von GPIOs.
Dies geschieht über Registeroperationen als eine klar strukturierte, objektorientierte Schnittstelle. 
Für Entwickler besteht somit die Möglichkeit, GPIOs einfach per Konstruktor und Methoden wie \texttt{set()}, \texttt{toggle()}, \texttt{mode()} oder \texttt{get()} zu verwenden, ohne sich mit den zugrunde liegenden Bitmanipulationen und der Clock-Konfiguration befassen zu müssen. 

Im Bereich der Verhaltensmuster finden sich mehrere Beispiele:

Das Template-Method Pattern findet in der \texttt{systick}-Komponente Anwendung. 
Der Ablauf der Interruptbehandlung ist in der entsprechenden Stelle explizit definiert, ermöglicht jedoch die Integration individueller Erweiterungspunkte, beispielsweise durch überschreibbare oder registrierbare Callbacks wie \texttt{onTick()}. 
Diese Erweiterungspunkte können angepasst werden, ohne dabei den Ablauf der Interruptbehandlung selbst zu modifizieren.

% TODO: Observer Pattern Erklärung
Ein weiteres Verhaltensmuster ist das Observer Pattern, das bei der Behandlung von GPIO-Interrupts zum Einsatz kommt.
Die Anwendung ist in der Lage, über Callbacks oder Eventhandler auf externe Ereignisse zu reagieren, die von der Peripherie ausgelöst und vom ISR (Interrupt Service Routine) weitergeleitet werden. 
Hieraus resultiert ein charakteristisches Beobachterverhältnis zwischen Hardwareereignis und Anwendungslogik.

Darüber hinaus lässt sich ein Strategy-Pattern in der SPI-Implementierung identifizieren, bei dem zur Compile- oder Laufzeit unterschiedliche Dma-Komponenten eingebunden werden können. 
Das Verhalten der Datenübertragung unterliegt einer dynamischen Veränderung durch den Austausch von Komponenten.
