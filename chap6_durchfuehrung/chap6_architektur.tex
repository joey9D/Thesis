\section{Architekturentwurf}

\label{sec:architecture_properties}
\subsection{Architektonische Eigenschaften der Treiber-API}
Moderen Softwarelösungen bestehen meist aus vielen, großen Dateien, die untereinander von einander abhängig sind.
Um bei solch großen Projekten den Überblick zu behalten, werden diese Softwarelösungen nach gewissen Eigenschaften erstellt.
Diese \emph{architektonischen Eigenschaften} lassen sich (grob) in drei Teilbereiche unterteilen: Betriebsrelevante, Strukturelle und Bereichsübergreifende \cite{barlik_architektur}, wie in Tabelle~\ref{tab:architektonische_eigenschaften} aufgeführt. % Eigenschaften. 

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c | c }
		\toprule
			\textbf{Betriebsrelevante} & \textbf{Strukturelle} & \textbf{Bereichsübergreifende}\\
			\midrule
			Verfügbarkeit & Erweiterbarkeit & Sicherheit\\
			Performance & Modularität & Rechtliches\\
			Skalierbarkeit & Wartbarkeit & Usability\\
			$\cdots$ & $\cdots$ & $\cdots$\\
			\bottomrule
		\end{tabular}
		\caption{Teilbereiche architektonischer Eigenschaften}
	    \label{tab:architektonische_eigenschaften}
	\end{center}
\end{table}

Aus diesen Eigenschaften gilt es, die wichtigsten für die Treiber-API zu identifizieren. 
Mit diesem Hintergrund lässt sich eine Struktur für das Projekt bilden.

Die Entwicklung einer plattformunabhängigen, wiederverwendbaren Treiber-API für Micro-controller stellt hohe Anforderungen an die Architektur der Softwarebibliothek.

% Welche (architektonischen) Eigenschaft sind wichtig/sollen umgesetzt werden?
% geringe Redundanz
Das Ziel besteht darin, eine Lösung zu schaffen, die sich durch eine geringe Redundanz auszeichnet. 
Die Konzeption von Klassen und Funktionen sollte derart erfolgen, dass eine erneute Implementierung der Applikation für jede neue Plattform nicht erforderlich ist.
Die Wiederverwendbarkeit zentraler Komponenten führt zu einer Reduktion des Entwicklungsaufwands und einer Erhöhung der Konsistenz im Code.

% Usability - Benutzerfreundlichkeit
Ein weiteres zentrales Anliegen ist die einfache Benutzbarkeit. 
Die API ist so zu gestalten, dass eine effiziente Nutzung gewährleistet ist. 
Dies fördert nicht nur die Effizienz in der Erstellung neuer Applikationen, sondern erleichtert auch langfristig die Wartung und Weiterentwicklung der Software.

% Skalierbarkeit
Im Sinne der Skalierbarkeit wird angestrebt, die Lösung auf möglichst viele Microcontroller-Architekturen und Hardwareplattformen anwendbar zu machen.
Die Vielfalt verfügbarer MCUs erfordert eine abstrahierte und flexibel erweiterbare Struktur, die die Integration neuer Plattformen mit minimalem Aufwand ermöglicht.

% TODO chap6: Eigenschaften: Portabilität, ja - nein?
% Portabilität - nochmal anpassen; OS Bezug passt nicht richtig
%Auch die Portabilität spielt eine wichtige Rolle.
%Die Bibliothek sollte nicht nur hardware-, sondern auch betriebssystemunabhängig konzipiert werden.
%Aus diesem Grund wird bei der Entwicklung der Lösung darauf geachtet, dass diese erst unter Windows, später auch unter Linux und macOS einsetzbar ist.
%Die Installation und Konfiguration der dafür benötigten Werkzeuge wird nachvollziehbar dokumentiert, um den Einstieg für die Nutzer zu erleichtern.

% Erweiterbarkeit
Darüber hinaus ist die Erweiterbarkeit ein wesentliches Architekturprinzip.
Der Einsatz von leistungsstärkeren Microcontrollern hängt in der Regel mit einer Erweiterung der Funktionalitäten zusammen, die in die bestehenden Treiber- und API-Strukturen integriert werden müssen.
Daher wird großer Wert auf eine modulare und offen gestaltete Architektur gelegt, die neue Features ohne grundlegende Umbauten aufnehmen kann.

% Modularität
Modularität trägt wesentlich zur Übersichtlichkeit und Wartbarkeit des Systems bei. 
Eine saubere Trennung funktionaler Einheiten ermöglicht eine schnellere Lokalisierung und Behebung von Fehlern, was wiederum die langfristige Pflege und Weiterentwicklung der Software erleichtert.

% (Ressourcen-)Effizienz
Schließlich ist auch die Effizienz ein kritischer Aspekt.
Da Microcontroller in der Regel nur über begrenzte Ressourcen verfügen, ist es essenziell, dass die Bibliothek möglichst kompakt und ressourcenschonend implementiert wird. 
Externe Abhängigkeiten werden bewusst auf ein Minimum reduziert, um Speicherplatz zu sparen und unnötige Komplexität zu vermeiden.

Diese architektonischen Prinzipien bilden die Grundlage für die Konzeption und Umsetzung der in dieser Arbeit vorgestellten Treiber-\gls{api}.


\subsection{Architektur- und Designmuster der Treiber-API}

%\begin{itemize}
%	\item Desgin Patterns $\rightarrow$ Aufbau der einzelnen Klassen
%	\begin{itemize}
%		\item Welche werden sonst eingesetzt; welches eignet sich für diesen Zweck
%		\item Wie sollen die Module der jeweiligen Peripherie aufgebaut sein?
%	\end{itemize}
%	\item HardwareInterface mit allen:
%	\begin{itemize}
%		\item vllt. Core: ClockInit, Delay, GetTick
%		\item Gpio
%		\item SPI
%%		\item UART
%		\item CAN
%	\end{itemize}
%\end{itemize}
%
%- Architektonische Eigenschaften\\
%- Welche Grundarchitektur liegt vor?\\
%- Welches Architekturmuster eignet sich dafür?\\
%- Welche Architektur eignet sich hier für? $\rightarrow$ Aufbau des gesamten Systems\\
%Um die Struktur der Treiber-\gls{api} zu erstellen, finden die in \cref{sec:architecture_design_pattern} angesprochenen Architektur- und Designmuster Verwendung.
%Da sich in der Embeddedwelt bewegt wird, handelt es bei der Gesamtstruktur um ein Schichtenarchitektur.
%Das fertige Projekt wird darin eine eigen Schicht bilden.
%Damit fehlen noch die Designmuster.
%Dieses müssen so ausgewählt werden, dass die Eigenschaften, die in vorherigem \cref{sec:architecture_properties} erarbeitet wurden, bestmöglich erfüllt werden.\\
%- C++ $\rightarrow$ Objekt-orientiert\\
%- Factory Architektur zur Erstellung von Objekten\\
%- Erstellung von Objekten?\\
%Beginnend bei der Auswahl der Hardware. 
%Factory-Methode:
%Interface ruft Factory auf, die eine Instanz des HW-Objektes zurückgibt.
%Mit dieser Instanz wird die Hardware initialisiert.
%Ein allgemeines Hardwareinterface kapselt Kernfunktionen der Hardware, die für die Systeminitialisierung und -funktionen relevant sind.
%
%
%Damit aus diesem Interface in Objekt einer spezifischen Hardware wird, bietet sich eine Fabrik an.
%Diese wählt anhand der in einer Konfigurationsdatei definierten Hardware die richtige Kindklasse der Interface-Elternklasse aus.
%
%Facade-Pattern:
%Eine hardware spezifischere Kindklasse implementiert die Kernfunktionen der Interfaceklasse, passend auf ihr System und erweitert diese um die Peripheriefunktionen.
%
%- Peripheriefunktionen (GPIO, SPI, etc.) als eigenständigen Klassen\\
%- Globales Interface\\
%- Auswahl der Funktionen\\
%Jede Peripheriefunktion wird genau wie die Hardware über eine Interface-Elternklasse und Hardware-spezifische Kindklassen implementiert.
%
%Mit diesem Konzept entsteht ein Modul für jede Peripherie, z.B. das GPIO-Modul.
%Diese Module sind so designed, dass sie den tiefergehenden Code hinter einer Facade verbergen.
%Durch die vorher definierte Hardware ändert sich am eigentlichen erstellt Programmcode nichts.
%Im Hintergrund werden aber die hardware-spezifischen Treiber und HAL Funktionen ausgewählt.
%Der Entwickler bekommt davon in der main.cpp nichts mit.

% Schichtenarchitektur
Die grundlegende Struktur des Systems basiert auf einer Schichtenarchitektur, wie sie in der Embedded-Softwareentwicklung häufig Anwendung findet. 
Diese Architekturform ermöglicht eine klare Trennung zwischen Anwendungslogik, Abstraktionsschichten und hardwarenahen Treibern. 
Die Schichtung erleichtert nicht nur die Wartung und Erweiterbarkeit, sondern trägt auch wesentlich zur Portabilität bei, da einzelne Schichten unabhängig voneinander angepasst oder ausgetauscht werden können. 
Das entwickelte Projekt bildet dabei eine eigenständige Schicht innerhalb dieser Gesamtarchitektur, die als Schnittstelle zwischen Hardware und Anwendung dient.


Aufgrund der Implementierung in der Programmiersprache C++ ist die Architektur durch die Prinzipien der Objektorientierung geprägt. 
Die in Klassen organisierte Kapselung von Zuständigkeiten sowie die Möglichkeit zur Nutzung von Vererbung und Polymorphie bilden eine geeignete Grundlage, um hardwarenahe Funktionalitäten abstrahiert und erweiterbar bereitzustellen. 
Diese Eigenschaften schaffen die Voraussetzung dafür, dass Designmuster gezielt eingesetzt werden können, um die im vorangehenden Abschnitt definierten Architekturziele
\begin{itemize}
	\item Skalierbarkeit
	\item Modularität
	\item Erweiterbarkeit
	\item geringe Redundanz
	\item Effizienz
	\item Benutzerfreundlichkeit
\end{itemize}
 zu erreichen.

% Factory Methode
Ein zentrales Muster stellt dabei die \textit{Factory-Methode} dar.
Dieses Erzeugungsmuster dient der Entkopplung von Objektinstanziierung und -nutzung.
Die Hardwareabstraktion definiert demnach ein allgemeines Hardwareinterface, das die notwendigen Basisfunktionen bereitstellt.
Die konkrete Auswahl und Instanziierung einer spezifischen Implementierung erfolgt über eine \textit{Fabrik}, die anhand der in einer Konfiguration hinterlegten Zielplattform das passende Objekt erzeugt.
Dadurch wird verhindert, dass anwendungsspezifischer Quellcode an hardwareabhängige Details gebunden ist.
Die Factory-Methode trägt somit wesentlich zur Erreichung von Plattformunabhängigkeit und Wiederverwendbarkeit des Anwendungscodes bei, da es auch ermöglicht, weitere Hardwareplattformen hinzuzufügen.

% Facade Pattern
In Erweiterung dessen findet das Facade-Pattern Verwendung. 
Dieses Strukturmuster dient der Vereinfachung des Zugriffs auf komplexe Subsysteme, indem es eine einheitliche Schnittstelle zur Verfügung stellt. 
In der vorliegenden Architektur werden die konkreten Implementierungen der im Interface definierten Kernfunktionen von hardwarespezifischen Kindklassen übernommen. 
Die Implementierungen werden dem Anwendungsentwickler über die Fassade in abstrahierter Form zugänglich gemacht. 
Hierdurch wird die interne Komplexität der hardwarenahen Treiber verborgen, während nach außen eine einheitliche und stabile Schnittstelle bereitgestellt wird.

% Modularisierung
Die Architektur kann durch die Modularisierung der Peripheriefunktionen weiter verfeinert werden. 
Funktionen wie GPIO und SPI werden jeweils als eigenständige Module entworfen, die wiederum dem Prinzip von Interface und spezifischer Implementierung folgen. 
Es ist zu berücksichtigen, dass jedes Modul die hardwarespezifischen Details hinter einer definierten Abstraktionsschicht kapselt. 
Diese konsequente Trennung gewährleistet, dass Änderungen in der Hardware oder den zugrunde liegenden Treibern keine Anpassungen am Anwendungscode erforderlich machen.

% Unbewusste Verwendung von Pattern
Im Rahmen der Implementierung von Entwurfsmustern, wie etwa der Factory- und des Facade-Pattern, entstehen weitere Muster sowohl bewusst als auch implizit. In \cref{tab:unconsious_design_pattern} sind neben den bewusst eingesetzten Muster auch mögliche Designmuster aufgelistet, die sich potentiell im Laufe der Implementierung unbewusst herausbilden und durch die gewählte Architektur- und Klassenstruktur realisiert werden.
% Strategy
Die Verwendung von Interfaces mit plattformspezifischen Implementierungen kann dem Strategy-Muster zugeordnet werden, da auf diese Weise unterschiedliche \textit{Strategien} zur Realisierung derselben Funktionalität austauschbar bereitgestellt werden.
% Adapter 
In Fällen, in denen die Schnittstellen der Hardware-API von den Funktionen der MCU HAL abweichen, ergibt sich zudem eine Abbildung auf das Adapter-Muster. 
% Singleton
Sofern die Anzahl der für bestimmte Peripherieeinheiten zulässigen Instanzen limitiert ist, beispielsweise auf eine konkrete SPI-Schnittstelle, resultieren daraus Strukturen, welche dem sog. Singleton-Muster entsprechen. 

Die Architektur fußt auf den Prinzipien der Schichtenarchitektur, der Objektorientierung sowie einer Kombination expliziter (Factory, Fassade) und impliziter (Strategy, Adapter, Singleton) Designmuster. 
Diese Kombination gewährleistet, dass die Softwareportabilität, Erweiterbarkeit und Wartbarkeit erreicht werden, während gleichzeitig die Komplexität für den Anwendungsentwickler reduziert wird.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{p{3cm} | p{4cm} | p{7cm}}
		\toprule
			\textbf{Muster} & \textbf{Art der Verwendung} & \textbf{Rolle und Nutzen im System} \\
			\midrule
			Factory-Methode & bewusst & Entkopplung von Objektinstanziierung und -nutzung; Auswahl der korrekten Hardwareimplementierung anhand der Konfiguration. \\
			Fassade & bewusst & Vereinfachung des Zugriffs auf komplexe Treiberdetails; Bereitstellung einer homogenen Schnittstelle für den Entwickler. \\
			Strategy & implizit & Austauschbare Implementierungen für Hardwarefunktionen (z. B. verschiedene GPIO- oder SPI-Strategien je nach Plattform). \\
			Adapter & implizit & Anpassung der definierten Schnittstellen an abweichende Funktionssignaturen der MCU HAL oder Registerzugriffe. \\
			Singleton & implizit & Gewährleistung, dass bestimmte Peripherieinstanzen (z. B. ein bestimmter SPI-Bus) nur einmal existieren. \\
			\bottomrule
		\end{tabular}
		\caption{Auflistung der bewusst verwendeten Designpattern. Daneben potentielle Muster, die während der Implementierung entstehen können.}
		\label{tab:unconsious_design_pattern}
	\end{center}
\end{table}



























