\section{Anforderungsanalyse}
Um eine benutzerfreundlichen und leistungsfähigen API-Bibliothek entwickeln zu können, ist es wichtig die grundlegenden Funktionen klar zu definieren.
So gilt es als erstes die Fragen zu klären: \emph{Was muss die API können?} und \emph{Welche Eigenschaften soll die API haben?}\\
% Allgemeines Ziel; Pin-Objekte
Es ist das übergeordnete Ziel, plattformunabhängigen Code schreiben zu können.
Das bedeutet, es muss möglich sein ein Programm, das z.B. für eine Hardware mit einem STM32-\gls{mcu} geschrieben wurde, auch für Hardware mit einer ESP32-\gls{mcu} funktionsfähig zu haben.
Die spezifische Konfiguration der Hardware und der Pins, wie sie beispielsweise mit STM32CubeMX gemacht werden kann, muss dennoch für jede Hardware, je nach Projekt, neu erstellt werden.
Dies liegt unter anderem an den unterschiedlichen Prozessorarchitekturen, der Anzahl an Pins und deren Zuordnung zu spezifischen Funktionen oder der Registerkonfiguration.
Um eine Pinkonfiguration mit Code zu lösen und von der graphischen Oberfläche wegzukommen, liegt der Gedanke nahe, Objekte zu verwenden.
Besonders im Kontext der Verwendung von C++.
Solche Objekt werden mittels eines Konstruktors, der die Werte für die Attribute der Pins übergeben bekommt, erstellt.
Bevor eine Erstellung dieser Pin-Objekte stattfinden kann, Aufgrund der angesprochen Unterschiede, muss erst die Hardware bekannt sein und kann darauf hin ausgewählt werden.
% Hardware- und Treiberauswahl
Damit die Pin-Objekte auch verwendet werden können, muss vorher die gewählte Hardware initialisiert werden.
Zu Beginn muss festgelegt werden, welche Hardware tatsächlich vorhanden ist. 
Auf dieser Basis muss die API automatisch die passenden Treiber auswählen, eine entsprechende Hardwareinstanz erstellen und diese dem Programm übergeben können. 
Über allgemein definierte Funktionen kann diese Instanz anschließend mit den richtigen Treibern initialisiert und verwendet werden.
Diese Definition kann beispielsweise über ein \texttt{\#define}, dass den Namen der Hardware beinhaltet, gelöst werden.
Mit Blick auf zukünftige Veränderungen sollte es auch so einfach wie möglich sein, weitere Hardware der API hinzu zu fügen, um die Auswahl zu erweitern.
Diese Veränderungen und Erweiterungen würden auch die jeweiligen Peripheriefunktionen betreffen.
Um einen klaren Überblick über diese Funktionen zu behalten, ist der Gedanke an Module zu betrachten.
So könnte für jede Peripheriefunktion (\gls{gpio}, \gls{spi}, \gls{uart}, \gls{can}) ein eigenes Modul implementiert werden.
Auf diese Weise hat man neben dem Überblick auch eine klare Struktur, die Fehlersuchen und Wartungen der Software wiederum vereinfacht.
% Peripheriemodule
Die Peripheriemodule müssen ähnlich der Hardwareauswahl, die Funktionen der Hardware kapseln.
Im Fall der STM32-\gls{mcu}s werden die Funktionen der eigenen \gls{hal}-Bibliothek verwendet.
ESP32 Hardware hat hierbei seine eigene \gls{hal} mit zugeschnittenen Funktionen.

