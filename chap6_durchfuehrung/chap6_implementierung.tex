\section{Implementierung}
Die Implementierung der zuvor entworfenen Architektur erfordert die sukzessive Übertragung der zuvor definierten Konzepte in lauffähigen Quellcode. 
Im Zentrum der Untersuchung stehen dabei zentrale Fragen: 
Wie wird ein bestimmter Architekturpunkt konkret umgesetzt?  
Welche Werkzeuge und Entwicklungsumgebungen sich für die jeweiligen Arbeitsschritte eignen? 
Aus welchen Gründen bestimmte Lösungswege gegenüber möglichen Alternativen bevorzugt wurden.


Im Folgenden wird die praktische Umsetzung einzelner Architekturkomponenten dargestellt.
 Im vorliegenden Kontext sind zunächst die Mechanismen zur Hardwareauswahl und Objekterstellung zu berücksichtigen, die im Rahmen des Factory-Patterns realisiert werden. 
 In der Folge werden die Peripheriemodule GPIO und SPI betrachtet, bei denen die Implementierung der Schnittstellen sowie die Abbildung auf plattformspezifische Details im Vordergrund stehen. 
 In einer sequenziellen Abfolge wird der Prozess veranschaulicht, in dessen Verlauf aus den Abstraktionen konkrete Funktionalität emergiert und die einzelnen Elemente in ihrer Interaktion dargestellt, um eine portable und erweiterbare Hardware-API bereitzustellen.
 
% Fragen
%Wie wird der jeweilige Punkt umgesetzt?
%
%Welche Tools werden benutzt/eignen sich besonders für die Umsetzung?
%Welche Tools eignen sich für welchen Arbeitsschritt?
%
%Warum wird etwas gerade auf diese Weise umgesetzt?
%
%
%
%Umsetzen des jeweiligen Architekturpunktes:
%Wie Factory, 
%Hardwareauswahl
%Objekterstellung
%Wie Peripherals: GPIO, SPI
%Objekterstellung
%Funktionsimplementierung

%Unterscheiden zwischen ESP32 und STM32
%
%Projektstruktur
%make
%Makefile
%config.mk
%
%CMake Struktur
%CMakeLists
%\\
%1. Struktur aufsetzen\\
%- man weiss was man braucht\\
%- ein Rootverzeichnis HW\_API, enthält alles: Treiber, Peripherie Module, Anleitung, CMake-Struktur, Makefile\\
%- als erstes die CMake-Struktur aufsetzen.\\
%- dazu wird der Verzeichnisbaum  grundlegend erstellt.\\
%- Verzeichnisse, die enthalten sein müssen, jedes mit eigenem CMakeLists.txt:\\
%-- app: enthält main.cpp und main.hpp\\
%-- HW\_API: API Root Verzeichnis\\
%-- HW\_API/core: enthält Dateien, die allgemein bzw. für mehr als eine Hardware gültig sind. 
%	Hier befindet sich die hw\_factory die die Hardware-Objekte erstellt, indem sie die richtigen Treiber anhand von definierten Makros auswählt; C++ Äquivalent zu C Strukturen: enum class, die Hardware-spezifische Makros zusammenfassen; das allgemeine Hardwareinterface, von dem alle unterstützte Hardware erbt.\\
%-- HW\_API/debug\_probes: enthält Hilfsdateien zum debuggen. Diese Dateien rufen im Hintergrund die entsprechenden Programme auf, die für die gewünschte Debug-Art bzw. für die verwendete Hardware notwendig sind.\\
%-- HW\_API/drivers/stm32\_hal\_wrapper bzw. /esp32\_hal\_wrapper: enthalten Hardware-spezifische Konfigurationsdateien für die jeweiligen Mikrocontroller-Plattformen, die als Brücke (Wrapper) zwischen der herstellerspezifischen Hardware-Abstraktionsschicht (HAL) und der plattformunabhängigen HW\_API dienen.
%	Die enthaltenen Konfigurationsdateien definieren Makros über:\\
%	--> Hardwareressourcen: Speichergröße, Peripherie-Ausstattung, Taktfrequenzen\\
%	--> Peripherie-Aktivierung: Welche Hardware-Module (GPIO, SPI, I2C, UART, etc.) aktiviert sind\\
%	--> Feature-Flags: Welche spezifischen Funktionen der jeweiligen HAL verwendet werden\\
%	--> Interrupt-Prioritäten: Konfiguration des NVIC (Nested Vectored Interrupt Controller)\\
%	--> Low-Level-Initialisierung: Hardware-spezifische Initialisierungssequenzen\\
%	Die Wrapper-Schicht ermöglicht es der HW\_API, mit einer einheitlichen Schnittstelle auf unterschiedliche Hardware zuzugreifen, während die plattformspezifischen Details vor den höheren Schichten verborgen bleiben. Dies ist ein wesentlicher Bestandteil der Hardware-Abstraktion und ermöglicht die Portierbarkeit der Anwendung zwischen verschiedenen Mikrocontroller-Familien.
%	Die Konfigurationsdateien werden beim Build-Prozess automatisch eingebunden und bestimmen das Verhalten der Hardware-Abstraktionsschicht auf der jeweiligen Zielplattform.\\
%-- HW\_API/platform: Dieses Verzeichnis bildet das Herzstück der Hardwareabstraktion und enthält die plattformspezifischen Implementierungen der Hardware-API. \\
%	Es ist nach folgendem Konzept strukturiert:\\
%	--> Plattform-Trennung: Separierte Unterordner für jede unterstützte Hardwareplattform (stm32, esp32)\\
%	--> Familie-Spezialisierung: Weitere Unterteilung nach Mikrocontroller-Familien (stm32c0, stm32f4, esp32s3)\\
%	--> Interface-Implementierung: Konkrete Implementierungen der in den Core-Modulen definierten abstrakten Interfaces\\
%	Schlüsselkomponenten:\\
%	--> Hardware-Treiber: Implementieren die konkreten Hardware-Zugriffsfunktionen\\
%	--> Register-Abstraktion: Kapseln direkten Register-Zugriff in typsichere C++-Interfaces\\
%	--> Hardware-Mapping: Übersetzen zwischen logischen Ressourcen und physischen Hardware-Adressen\\
%	--> Interrupt-Handler: Plattformspezifische Interrupt-Implementierungen\\
%	--> Clock-Konfiguration: MCU-spezifische Takteinstellungen und Power-Management\\
%	Die Plattform-Schicht nutzt die HAL-Wrapper (aus dem drivers-Verzeichnis) und bietet nach oben eine einheitliche Schnittstelle für die Core-Module. \\
%	Dies ermöglicht es, dass der Rest der Applikation hardwareunabhängig bleibt, während diese Schicht die tatsächlichen Unterschiede zwischen den Mikrocontroller-Plattformen abstrahiert.\\
%	Ein wesentliches Designprinzip ist, dass alle hardwarespezifischen Details innerhalb dieser Schicht gekapselt bleiben und nicht in höhere Schichten durchsickern.\\
%-- HW\_API/peripherie Modul (gpio, spi, can, ...): Diese Verzeichnisse enthalten die Peripherie-spezifischen Module der Hardware-Abstraktionsschicht für GPIO (General Purpose Input/Output) und SPI (Serial Peripheral Interface). \\
%	Sie bilden die Brücke zwischen den generischen Hardware-Interfaces und den konkreten Implementierungen für verschiedene Plattformen.\\
%	Struktur und Komponenten:\\
%	--> Interface-Definitionen: Abstrakte Basisklassen und Interfaces, die die Funktionalität der jeweiligen Peripherie definieren\\
%	--> Gemeinsame Datentypen: Enums, Strukturen und Konstanten, die die Konfigurationsparameter der Peripherie repräsentieren\\
%	--> Plattformunabhängige Logik: Gemeinsamer Code, der für alle Plattformen gleich funktioniert\\
%	--> Factory-Klassen: Erzeugen plattformspezifische Implementierungen basierend auf Konfigurationsparametern\\
%	Typische Dateien im GPIO-Modul:\\
%	--> gpio\_interface.hpp: Definiert die abstrakte GPIO-Schnittstelle\\
%	--> gpio\_types.hpp: Gemeinsame Datentypen wie PinMode, PullType, etc.\\
%	Typische Dateien im SPI-Modul:\\
%	--> spi\_interface.hpp: Definiert die abstrakte SPI-Schnittstelle\\
%	--> spi\_types.hpp: Datentypen für SPI-Konfigurationen (Mode, Geschwindigkeit, Bit-Reihenfolge)\\
%	Diese Module arbeiten eng mit dem Platform-Layer zusammen, der die tatsächlichen Hardware-spezifischen Implementierungen enthält.\\ Die Anwendung interagiert nur mit den abstrakten Interfaces, während die konkreten Implementierungen zur Kompilierzeit basierend auf der Zielplattform ausgewählt werden.\\
%	Die Peripherie-Module sind so konzipiert, dass sie einfach erweiterbar sind und neue Hardware-Plattformen mit minimalen Änderungen integriert werden können, indem lediglich plattformspezifische Implementierungen hinzugefügt werden, ohne die öffentlichen Schnittstellen zu ändern.\\
%-- toolchains: enthält .cmake-Dateien, die die Hardwarespezifischen Compiler \\
%	Dieses Verzeichnis enthält die CMake-Toolchain-Dateien, die für die Cross-Compilation auf verschiedene Zielplattformen essentiell sind.\\
%	Sie definieren die grundlegenden Compiler-Werkzeuge und Einstellungen, die CMake verwenden soll, um Code für die jeweiligen Mikrocontroller zu kompilieren.\\
%	Wichtige Toolchain-Dateien:\\
%	--> stm32-toolchain.cmake: Konfiguriert den ARM-GCC-Toolchain für STM32-Mikrocontroller\\
%	--> esp32-toolchain.cmake: Konfiguriert den Xtensa-ESP32-Toolchain für ESP32-Mikrocontroller\\
%	Diese Dateien definieren:
%	--> Compiler-Pfade: Lokalisierung der plattformspezifischen Cross-Compiler (arm-none-eabi-gcc, xtensa-esp32-elf-gcc)\\
%	--> Basis-Compiler-Flags: MCU-spezifische Optionen wie CPU-Typ, FPU-Einstellungen und ABI\\
%	--> Optimierungs-Einstellungen: Debug- und Release-Konfigurationen mit entsprechenden Optimierungsstufen\\
%	--> Linker-Einstellungen: Memory-Sections, Garbage Collection und spezielle Embedded-Linker-Flags\\
%	--> Hilfswerkzeuge: Konfiguration von objcopy, objdump und size für Binary-Manipulation\\
%	--> Build-Typen: Definitionen für Debug, Release und andere Build-Konfigurationen\\
%	Die Toolchain-Dateien werden beim CMake-Aufruf durch den -DCMAKE\_TOOLCHAIN\_FILE-Parameter eingebunden und stellen sicher, dass der gesamte Build-Prozess mit den korrekten Werkzeugen und Einstellungen für die Zielplattform durchgeführt wird.\\
%	Sie sind ein kritischer Bestandteil des Cross-Compilation-Workflows und ermöglichen die Entwicklung auf einem Host-System für eine andere Zielarchitektur.\\
%	Diese Konfigurationsdateien werden vom Makefile-System automatisch ausgewählt, basierend auf der gewählten Zielplattform, sodass Entwickler nicht manuell zwischen verschiedenen Toolchains wechseln müssen.

% fliess text
\subsection{Struktur}
\begin{figure}[H]
\begin{forest}
for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) ++(0.5em,0) |- (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=1.5em},
    s sep=2pt,
}
[Project-Root
  [app
    [main.cpp]
    [main.hpp]
  ]
  [HW\_API
  	[core
    	[hw\_factory.hpp]
	    [hardware\_interface.hpp]
  	]
  	[debug\_probes]
  	[drivers
    	[stm32\_hal\_wrapper]
    	[esp32\_hal\_wrapper]
  	]
  	[platform
    	[stm32
      		[stm32c0]
      		[stm32f4]
    	]
    	[esp32
      		[esp32s3]
    	]
  	]
    [gpio
      	[gpio\_interface.hpp]
      	[gpio\_<hardware spezifisch>.hpp]
      	[gpio\_<hardware spezifisch>.cpp]
    ]
    [spi
    	[spi\_interface.hpp]
		[spi\_<hardware spezifisch>.hpp]
		[spi\_<hardware spezifisch>.cpp]
    ]
    [weitere Peripheriefunktionen ...]
  ]
  [toolchains
    [stm32-toolchain.cmake]
    [esp32-toolchain.cmake]
  ]
]
\end{forest}
\caption{Verzeichnisbaum des Beispielprojektes.}
\label{fig:project_tree}
\end{figure}

Um das Projekt erfolgreich aufzubauen, ist es von entscheidender Bedeutung, zunächst eine klare und erweiterbare Verzeichnisstruktur zu definieren. 
Im Projekt-Root-Verzeichnis befindet sich dazu das Hauptverzeichnis HW\_API, das als zentrales Element der Hardwareabstraktion dient und alle wesentlichen Bestandteile enthält. 
Zu den erforderlichen Komponenten zählen Treiber, Peripherie-Module, Debug-Hilfen, Toolchains sowie die notwendigen Build-Dateien (CMake-Struktur, Makefile). 
Diese Struktur gewährleistet, dass das Projekt modular, portierbar und für verschiedene Mikrocontroller-Familien leicht erweiterbar bleibt.
Zunächst wird eine grundlegende CMake-Struktur aufgesetzt. 
Jedes Unterverzeichnis enthält dabei ein eigene CMakeLists.txt, sodass sich einzelne Komponenten unabhängig in das Build-System integrieren lassen. 
Die gesamte verwendete Struktur ist in \cref{fig:project_tree} zu sehen.
Zu den relevanten Verzeichnissen zählen:

\subsection*{app}
Dieses Verzeichnis beinhaltet die Anwendungsebene mit der main.cpp sowie einer zugehörigen main.hpp. 
In diesem Bereich erfolgt die Implementierung der eigentlichen Applikationslogik, die in ihrer Funktionsweise vollständig unabhängig von den unterliegenden, hardwarespezifischen Schichten bleibt.

\subsection*{HW\_API}
Hierbei handelt es sich um das zentrale Verzeichnis der Hardwareabstraktion, das in mehrere spezialisierte Unterordner unterteilt ist.
Diese Unterverzeichnisse sind die folgenden.

\subsubsection*{core}
Dieses Verzeichnis umfasst alle Dateien, die entweder allgemein gültig sind oder für mehr als eine Plattform genutzt werden können. 
Ein Beispiel dafür ist die Hardware Factory, die anhand vordefinierter Makros das passende Hardware-Objekt erzeugt.

Des Weiteren beinhaltet core das zentrale Hardware-Interface, von dem alle unterstützten Plattformen abgeleitet werden.

\subsubsection*{debug\_probes}
Das vorliegende Verzeichnis beinhaltet Hilfsdateien, die für das Debuggen von Software verwendet werden können.
Abhängig von der gewählten Debug-Methode oder der Zielhardware werden hier spezifische Programme aufgerufen, beispielsweise STLink für STM32-Hardware.
Dadurch ist es dem Entwickler möglich, eine einheitliche Debug-Schnittstelle zu nutzen, ohne sich mit plattformspezifischen Details befassen zu müssen.

\subsubsection*{drivers}
In den Unterordnern stm32\_hal\_wrapper und esp32\_hal\_wrapper dieses Verzeichnisses finden sich die für die jeweiligen Plattformen spezifischen Hardwarekonfigurationsdateien.
Diese Wrapper dienen als Bindeglied zwischen der vom Hersteller bereitgestellten \gls{hal} und der plattformunabhängigen HW\_API.
Die Konfigurationsdateien definieren unter anderem:
\begin{itemize}
	\item Hardwareressourcen wie Speichergrößen, Peripherie-Ausstattung, Taktfrequenzen,
	\item Peripherie-Aktivierung, d.h. welche Module (GPIO, SPI, I²C etc.) aktiv sind,
	\item Feature-Flags, die definieren, welche speziellen Funktionen der jeweiligen HAL genutzt werden,
	\item Interrupt-Prioritäten, die die Reihenfolge festlegen, in der verschiedene Interruptquellen vom NVIC abgearbeitet werden und
	\item Low-Level-Initialisierung, die plattformabhängige Sequenzen beim Start beschreiben.
\end{itemize}

Auf diese Weise wird gewährleistet, dass die HW\_API auf sämtlichen Plattformen mit identischer Schnittstelle operiert, während die plattformspezifischen Unterschiede verborgen bleiben.

\subsubsection*{platform}
Dieses Verzeichnis nimmt eine zentrale Stellung im Rahmen der Hardwareabstraktion ein, da es die plattformspezifischen Implementierungen der HW\_API enthält.
Die Struktur zeichnet sich durch eine mehrere Ebenen umfassende Aufteilung aus.

Im Rahmen der Plattform-Trennung werden zunächst separate Unterordner für jede unterstützte Plattform, wie beispielsweise \textit{stm32} oder \textit{esp32}, erstellt. 
Innerhalb dieser Plattformverzeichnisse erfolgt eine weitere Unterteilung nach spezifischen Mikrocontroller-Familien, etwa \textit{stm32c0}, \textit{stm32f4} oder \textit{esp32s3}. 
Diese Struktur ermöglicht eine klare Trennung der Implementierungen und erleichtert die Erweiterbarkeit um zusätzliche Plattformen.

Im Zuge der Interface-Implementierung erfolgt die konkrete Umsetzung der im Verzeichnis \textit{core} definierten abstrakten Schnittstellen. 
Die Schlüsselkomponenten dieser Schicht umfassen mehrere zentrale Aspekte. 
Zunächst implementieren die jeweiligen Hardware-Treiber den eigentlichen Zugriff auf Register.
Die Register-Abstraktion gewährleistet eine Kapselung direkter Registerzugriffe in typsichere C++-Interfaces. 
Dadurch wird das Risiko von Fehlbedienungen reduziert und die Lesbarkeit des Codes optimiert.

Ein weiterer essenzieller Bestandteil ist das Hardware-Mapping, das die logische Abbildung von Ressourcen, wie etwa GPIO-Pins, auf physische Speicheradressen vornimmt. 
Die Interrupt-Handler-Dateien sind für die plattformspezifische Ereignisbehandlung zuständig, sodass Interrupts korrekt verarbeitet und an die übergeordneten Schichten weitergeleitet werden. 
Schließlich beinhaltet die Clock-Konfiguration die Definition von Takteinstellungen und Power-Management-Parametern, die für jede Mikrocontroller-Familie spezifisch angepasst werden müssen.

Die Plattformschicht greift dabei auf die HAL-Wrapper aus dem Verzeichnis "drivers" zurück, stellt jedoch nach oben stets eine einheitliche Schnittstelle bereit. 
Ein zentrales Designprinzip besteht darin, dass alle hardwarespezifischen Details innerhalb dieser Schicht gekapselt bleiben und nicht in höhere Ebenen durchsickern. 
Die Gewährleistung der Portabilität und Wiederverwendbarkeit der gesamten Hardware-API wird durch diesen Prozess sichergestellt.

\subsubsection*{Peripheriemodule}
In Unterordnern wie gpio, spi oder can sind die Peripherie-spezifischen Module organisiert. 
Diese Module bilden die Schnittstelle zwischen den abstrakten Interfaces und den plattformspezifischen Implementierungen.
Zu den typischen Inhalten zählen:
\begin{itemize}
	\item Interface-Definitionen, die als Basis für jede Hardware diene.
	\item Header, die die hardwarespezifischen Klassen definieren, abgeleitet von den Interfaces.
	\item Konkrete Implementierungen der jeweiligen Header.
\end{itemize}

Auf diese Weise muss nur die Implementierung für die verwendete Hardware in das Projekt inkludiert werden.
Dies erleichtert die Erweiterbarkeit erheblich, da neue Plattformen durch Hinzufügen neuer Implementierungen integriert werden können, ohne die bereits bestehenden Dateien zu verändern.


\subsection*{toolchains}
Dieses Verzeichnis beinhaltet die erforderlichen .cmake-Dateien, die für die Cross-Compilation auf unterschiedlichen Zielplattformen essenziell sind.
Diese Toolchain-Dateien definieren unter anderem die Pfade zu den entsprechenden Compilern, wie beispielsweise arm-none-eabi-gcc oder xtensa-esp32-elf-gcc. Darüber hinaus umfassen sie die notwendigen Compiler-Flags, die den CPU-Typ, die FPU (Floating Point Unit)-Einstellungen sowie das ABI (Application Binary Interface) festlegen. 
Darüber hinaus werden auch Optimierungs-Settings für Debug- und Release-Builds berücksichtigt. Darüber hinaus werden die Einstellungen für das Speicherlayout, die Garbage Collection sowie spezifische Embedded-Flags festgelegt. 
Hier finden Hilfswerkzeuge wie \texttt{objcopy}, \texttt{objdump} und \texttt{size} Anwendung.
Der Aufruf von CMake mit dem Parameter \texttt{-DCMAKE\_TOOLCHAIN\_FILE} führt zur Einbindung der entsprechenden Toolchain. 
Daraufhin wird für den gesamten Build-Prozess die Bereitstellung der geeigneten Werkzeuge für die jeweilige Plattform sichergestellt

\vspace{0.5em}
\noindent\rule{\linewidth}{0.4pt}
\vspace{0.5em}

Die sorgfältig entworfenen CMake-Konfiguration ermöglicht eine flexible Cross-Compilation für verschiedene Mikrocontroller-Plattformen.
In diesem Fall aufgebaut und getestet mit STM32 und ESP32. 
Die Architektur folgt einem hierarchischen Aufbau mit klarer Trennung von Verantwortlichkeiten und einer konsequenten Abstraktion von plattformspezifischem Code.

Im Zentrum steht die Haupt-CMakeLists.txt im Rootverzeichnis des Projekts. 
Sie übernimmt die Plattformerkennung und muss anhand der definierten Makros entscheiden, welche Pakete für die Zielhardware hinzugefügt werden müssen. 
Die Information über die Zielhardware bekommt CMake über das Makefile, dass sich ebenfalls im Projektroot befindet und den zentralen Einstiegspunkt darstellt.
In diesem werden die komplexen und teilweise langen CMake-Befehle durch simplere Make-Aliasse ersetzt.
Auf diese Weise können die jeweiligen Prozesse Build, Flash oder Debug einfach über die Kommandozeile gestartet werden, ohne dass ein Befehl mit mehreren Flags wiederholt neu eingegeben werden muss. 
Im Makefile muss angegeben werden, welche Konfigurationsdatei verwendet werden muss.
In dieser Arbeit wurden zwei solcher Dateien erstellt:

\begin{itemize}
	\item stm32\_config.mk
	\item esp32\_config.mk
\end{itemize}

Diese fassen die Information zusammen, welche Treiber, welche Toolchain oder welche Debugvariante verwendet werden soll.
Die Toolchain definiert den Cross-Compile-Kontext, konfiguriert den verwendeten Compiler, z.B. arm-none-eabi-gcc für STM32), setzt CPU- und ABI-spezifische Flags (z. B. -mcpu=cortex-m0plus, -mthumb), die beschreiben wie Daten zwischen Compiler, Betriebssystem und Bibliotheken übergeben werden.
Für ESP32 wird analog die esp32-toolchain.cmake genutzt, die auf das IDF verweist.
Zusätzlich sind hier auch hardwarespezifische Informationen, die beschreiben um welchen Prozessor es sich handelt, welcher Chip die Hardware hat oder welche explizite Hardware verwendet wird.
Auch sind das Zielverzeichnis des Builds und die Art des Build, d.h. Debug oder Release, hier benannt.
Diese Informationen werden im Code selber verwendet, um bestimmte Teil aktivieren zu können.
Stichwort \textit{bedingte Kompilierung}, was bedeutet, dass Codeteile, die nicht definiert sind durch solche Makros, im Kompilier- und Buildprozess garnicht erst beachtet werden und auch nicht im entgültigen Programm enthalten sind, wodurch Speicher eingespart wird.
Neben dem Entgegennehmen und der Weiterverarbeitung der Informationen aus dem Makefile, setzt die Root-Datei globalen Standards wie C11 und C++17, legt Compiler-Flags für Debug- und Release-Builds fest und steuert die Reihenfolge der Subdirectory-Builds.
Für diese Reihenfolge ist es entscheidend, das erst die HW\_API-Libraries und zuletzt die Applikation gelistet ist, da diese die Funktionen verwendet, die in der HW\_API definiert sind.

Auf der zweiten Ebene übernimmt die CMake-Datei im HW\_API-Verzeichnis die Koordination der Module. 
Sie erzwingt die Nutzung von C++17 ohne Compiler-Extensions, aktiviert strengere Warnungen für Embedded-Code und bindet die verwendeten Unterverzeichnisse (core, drivers, gpio, platform, spi) in der korrekten Reihenfolge ein.
Damit werden die plattformneutralen Schnittstellen definiert und zugleich die plattformspezifischen Implementierungen vorbereitet. 
Die einzelnen Funktionsmodule erzeugen jeweils ihre eigene statische Bibliothek mit klar abgegrenzten Abhängigkeiten. 
Über bedingte Kompilierung und die CMake-Variable TARGET\_PLATFORM werden dabei nur die jeweils benötigten Quellen berücksichtigt, sodass eine saubere Trennung zwischen generischen Interfaces und konkreten Implementierungen gewährleistet bleibt.

Ein zentrales Element stellt das drivers-Modul dar, das insbesondere für STM32 die HAL- und CMSIS-Bibliotheken dynamisch über CMake-FetchContent integriert. 
Dazu erwartet es Repositoriums-Parameter, die im Makefile definiert werden, etwa STM32\_HAL\_REPO, STM32\_CMSIS\_REPO, ARM\_CMSIS\_REPO samt den jeweiligen Tags. 
Abhängig von der ausgewählten MCU-Familie (z. B. stm32c0xx, stm32g0xx) werden die passenden Startup-Dateien, Systemquellen und HAL-Komponenten eingebunden. 
% TODO: drivers/CMakeLists überarbeiten
Anschließend wird eine statische Bibliothek (stm32\_hal\_library) erstellt, deren Include-Pfade, Compiler-Definitionen (z. B. USE\_HAL\_DRIVER, STM32C0xx) und Wrapper-Files wiederum PUBLIC an abhängige Targets exportiert werden. 
Damit entsteht eine saubere, wiederverwendbare Treiberbibliothek, die in den plattformspezifischen Implementierungen genutzt werden kann.

Diese Implementierungen sind im platform-Verzeichnis organisiert und enthalten die konkreten hardwarespezifischen Realisierungen. 
Dort wird das zuvor erstellte Treiber-Modul verlinkt, es werden familienspezifische Konfigurationen eingebunden und die notwendigen Interrupt-Routinen integriert. 
Parallel dazu liefern die Peripherie-Module, bestehend aus Interface, Header- und Implementierungsdatei die plattformneutralen Schnittstellen.

Den Abschluss bildet die Anwendungsebene, in der ein ausführbares Target erzeugt wird. 
Diese Ebene bindet die zuvor erstellten HW\_API-Bibliotheken ein, übernimmt alle relevanten Include-Pfade und Definitionen und fügt post-build Schritte hinzu, beispielsweise die Erzeugung von Binary-Dateien für den Flash-Prozess.

Das Build-System zeichnet sich durch mehrere Schlüsselkonzepte aus: Die Plattformabstraktion wird konsequent über bedingte Kompilierung und Definitionen wie STM32\_PLATFORM realisiert.
Die Abhängigkeiten werden dynamisch verwaltet, indem die STM32-Bibliotheken via FetchContent geladen werden. 
Die modulare Bibliotheksstruktur ermöglicht es, jedes Modul isoliert zu bauen und dabei klare Schnittstellen und Abhängigkeiten einzuhalten. 
Während STM32 einem klassischen Cross-Compilation-Ansatz mit Toolchain-Datei folgt, wird ESP32 über das Component-System des eigenen ESP-IDF integriert.

Besondere Robustheit erzielt das System durch umfangreiche Diagnoseausgaben und Validierungen: Bereits in der Root-CMakeLists werden Plattform und Parameter geprüft, während die Drivers-CMakeLists ausführliche STATUS-Meldungen zum Repositories, Familienauswahl und aktiven Quellen liefern. 
Fehlerhafte oder fehlende Pflichtparameter führen zu einem FATAL\_ERROR und verhindern so inkonsistente Builds. 
Ergänzt wird dies durch eine flexible Include-Hierarchie mit PUBLIC/PRIVATE/INTERFACE-Abstufungen, wodurch eine präzise Abgrenzung der API erreicht wird.

Insgesamt ermöglicht diese CMake-Struktur die Kapselung von hardwarespezifischem Code bei gleichzeitiger Bereitstellung einer konsistenten API für Anwendungen. 
Damit bildet sie eine robuste Grundlage für eine effektive und plattformübergreifende Hardware-Abstraktionsschicht, die sowohl STM32- als auch ESP32-Umgebungen unterstützt.

\subsection{Klassen}
Die Hardware-Abstraktionsschicht des HW\_API-Projekts demonstriert ein klassisches objektbasiertes Interface-Implementierung-Muster und trennt strikt zwischen plattformunabhängigen Interfaces und plattformspezifischen Konkretisierungen. 
Im Verzeichnis core definieren hw\_interface.hpp und hw\_enum\_classes.hpp die gemeinsame Abstraktionseben:\\
% TODO: chap6: UML Diagramme einfügen
Die Auswahl der passenden Plattformklasse erfolgt zur Compile-Zeit über hw\_factory.hpp.
Per Präprozessor-Define (z. B. STM32C0xx, STM32G0xx, ESP32C6) wird genau eine konkrete Implementierung als statischer Singleton bereitgestellt und tiefere Abschnitte in den Implementierungen der Peripherieklassen freigeschalten.
Das sorgt für einen stabilen Lebenszyklus und vermeidet mehrfachen Besitz von Systemressourcen; die eigentliche Initialisierung bleibt jedoch explizit über Methoden wie \texttt{init\_sys()} und \texttt{init\_clock()}.

\subsubsection{Hardwareklassen}
Im Zentrum steht die abstrakte Basisklasse \texttt{HardwareInterface}, die in hw\_interface.hpp als rein virtuelle Schnittstelle definiert wird. 
Über diese prägnante Kernschnittstelle werden vier essentielle Methoden deklariert:

\begin{itemize}
	\item \texttt{init\_sys()} zur Systeminitialisierung, 
	\item \texttt{init\_clock()} zur Takteinrichtung,
	\item \texttt{delay()} für zeitliche Verzögerungen, sowie 
	\item \texttt{initAllPins()} zur gebündelten GPIO-Initialisierung.
\end{itemize}

Durch den virtuellen Destruktor wird eine saubere polymorphe Ressourcenfreigabe sichergestellt.
Die konkreten Hardware-Implementierungen teilen sich in zwei klar getrennte Plattformzweige auf: STM32 und ESP32. 
Hier können zukünftige weitere Zweige hizukommen.
Die STM32c0xx\_HW-Klasse in stm32c0xx\_hw.hpp/.cpp ist für das STM32-spezifische Hardware-Setup zuständig.
Ihre \texttt{init\_sys()}-Methode enthält einen besonderen Mechanismus mit dem potentielle Fehler verhindert werden:
Durch den Aufruf von \texttt{MSP\_ForceInclude()} wird sichergestellt, dass der Linker die kritische MSP-Initialisierungsfunktion \texttt{HAL\_MspInit()} einbindet. 
Diese könnte sonst wegen fehlender direkter Referenzen eliminiert werden und für Fehlverhalten im Buildprozess sorgen.
Die Taktinitialisierung nutzt moderne C++17-Features wie Aggregat-Initialisierung für \texttt{RCC\_OscInitTypeDef} und \texttt{RCC\_ClkInitTypeDef} mit 

\begin{itemize}
	\item \texttt{RCC\_OscInitTypeDef OscInitStruct{}}
	\item \texttt{RCC\_ClkInitTypeDef ClkInitStruct{}}
\end{itemize}

, konfiguriert das System für den internen HSI-Oszillator und setzt alle notwendigen Teiler in den jeweiligen Strukturen.
Fehlerfälle werden mit einem \texttt{ErrorHandler()} behandelt, der Interrupts deaktiviert und das System in eine Endlosschleife versetzt.
Dies entspricht einer typischen Vorgehensweise bei Embedded-Systemen.

Im Gegensatz dazu zeigt die Esp32c6\_hw-Klasse in esp32c6\_devkitc1\_hw.hpp/.cpp einen gänzlich abweichenden Ansatz.
Die Methoden \texttt{init\_sys()} und \texttt{init\_clock()} sind, bis auf erklärende Kommentare, leer.
ESP-IDF übernimmt hier die gesamte Initialisierung der Hardware.
Dies verdeutlicht den grundlegenden Unterschied zwischen der STM32-HAL, die eher auf die Low-Level Steuerung angelegt ist, und dem höher abstrahierten ESP-IDF-Framework.
Die Implementierung von \texttt{delay()} nutzt zur Vermeidung unnötiger Abhängigkeiten eine Busy-Wait-Schleife, die auf esp\_timer\_get\_time() basiert, anstelle der FreeRTOS-Funktionen.
Darüber hinaus bietet die ESP32-Implementierung plattformspezifische Erweiterungen wie \texttt{getFreeHeapSize(), getMinimumFreeHeapSize()} und \texttt{restart()}, die die spezifischen Fähigkeiten dieser Plattform nutzen.

Zu beachten ist die gemeinsame Strategie für \texttt{initAllPins()}, die in beiden Implementierungen identisch ist: 
Eine for-Schleife iteriert durch \texttt{boardPins.allPins}.
Dabei handelt es sich um ein Array, das in definiert project\_config.hpp ist und alle definierten Gpio-Objekte enthält.
Innerhalb der Schleife wird für jeden Pin \texttt{gpio\_init()} aufgerufen.
Diese elegante Lösung zentralisiert die Pin-Konfiguration an einer Stelle und vereinfacht die Board-Migration erheblich. 
Sie ist ein Beispiel für die Verwendung der Komposition Designs, da die tatsächlichen Pin-Objekte nicht Teil der HardwareInterface-Hierarchie sind, sondern als separate Komponenten verwaltet werden.

Die Implementierungen zeigen zwei unterschiedliche Philosophien der Embedded-Programmierung: 
Die Konfiguration des STM32 erfordert eine detaillierte und explizite Gestaltung jedes Hardwareaspekts, was charakteristisch für klassische Mikrocontroller ist.
Demgegenüber bietet das ESP32 einen höheren Abstraktionsgrad mit automatischer Ressourcenverwaltung, was charakteristisch für moderne SoCs (System on Chips) ist.
Trotz dieser fundamentalen Unterschiede ermöglicht die gemeinsame HardwareInterface-Schnittstelle eine einheitliche Interaktion mit der Hardware aus Anwendungssicht, was ein Kernziel jeder guten Abstraktionsschicht ist.

\subsubsection{Peripherieklassen}
Das GPIO-Modul folgt demselben Muster.
gpio\_interface.hpp, das in \cref{lst:gpio_interface} zu sehen ist, stellt mit \texttt{IGpioBase<T>} ein generisches Interface als Template-Klasse bereit; über Type-Aliases wie \textit{T} bzw. hier \textit{PinType}, werden die Plattformen auf den passenden Pin-Typ gemappt:
% IGpio
\begin{itemize}
	\item STM32: uint16\_t
	\item ESP32: uint64\_t
\end{itemize}

\begin{lstlisting}[language=C++, caption={Ausschnitt aus der Interfaceklasse IGpioBase.}, label={lst:gpio_interface}]
template <typename PinType>
class IGpioBase
{
	...
    virtual PinType getPin() const = 0;
	...	
};

// Platform-specific Type-Aliases
#ifdef STM32_PLATFORM
using IGpio = IGpioBase<uint16_t>;
#elif defined(ESP_PLATFORM) || defined(ESP32_PLATFORM)
using IGpio = IGpioBase<uint64_t>;
#endif
\end{lstlisting}

Die STM32-Implementierungen (gpio\_stm32.hpp/.cpp) binden die HAL über einen Wrapper-Header (stm32\_hal\_inc.hpp) ein und weist die API-Enums (Mode, Pull, Speed, Alternate) über lokale Helper-Funktionen auf HAL-Konstanten.
So eine \texttt{enum class} fasst die HAL-spezifischen Makros in sich zusammen und weist diesesn jeweils eine vereinfachte und generische Bezeichnungen (None statt GPIO\_NOPULL) zu.
Damit im späteren Verlauf des Codes keine zusätzliche Typumwandlung stattfinden muss, wird die Enumeration mit der Typenzuweisung uint32\_t deklariert.
Anhand dieser Bezeichnungen wählen die Hilfsfunktionen mit swtich-case-Strukturen die richtigen Werte für die Initialisierung aus.

Die Methode \texttt{gpio\_init()} übernimmt die gesamte Konfiguration, ähnlich der der Funktion \texttt{MX\_GPIO\_init()}, die in einem STM32CubeIDE Projekt generiert wird und die Pins initialisiert.
So werden hier, je nach im Objekt definierten Port, die entsprechende interne Clock aktiviert, für den gewünschten Pin eine Maske erstellt und über die Hilfsfunktionen, die den entsprechenden Wert mit übergeben bekommen, z.B. \texttt{modeToHAL(Mode mode)} bekommt den Wert \texttt{Alternate\_Push\_Pull}, die richtigen HAL-Makros ausgewählt und in die Initialisierungsstruktur eingefügt. 

\begin{lstlisting}[language=C++, caption={Beispiel eines Gpio Objektes.}, label={lst:gpio_object}]
Gpio spi1_mosi{
	5,							// uin16_t pin
	Port::B, 					// Port port
	Mode::Alternate_Push_Pull,	// Mode mode
	Pull::None, 					// Pull pull
	Speed::Very_High, 			// Speed speed
	Alternate::SPI_AF0, 		// Alternate Funciton
	false, 						// bool isPinInverted
	0, 							// uin32_t debounceTime
	0, 							// uin32_t debounceState
	ExtiTrigger::None			// External Interrupt Trigger
};
\end{lstlisting}

Ein solches Objekt ist in \cref{lst:gpio_object} dargestellt.
Das Objekt \texttt{spi1\_mosi} setzt dem Muster des Konstruktors nach die Werte der Attribute.
Die Methoden \texttt{readPin}, \texttt{writePin}, \texttt{togglePin} sind dünne Wrapper um die HAL-Funktionen.
Funktionen wie \texttt{isPinOn()} und \texttt{isDebouncePinOn()} modellieren Entprelllogik als kleinen Zustandsautomaten und berücksichtigen ob ein Pin möglicherweise invertiert ist.
Die korrekte Wahl des Ports erfolgt über stm32x0\_gpio\_mapping.hpp, das die Port-Enums auf GPIO\_TypeDef*-Zeiger abbildet.
Da nicht jede STM32-Hardware die gleiche Anzahl an Ports und teilweise nicht alle verfügbar sind, findet hier das Mapping statt.
Aktuell sind hier die Ports definiert für die in der Arbeit verwendete Hardware.
Für weitere Hardware muss diese Datei um deren Portdefinitionen erweitert werden.
Die Implementierung für die ESP32-Hardware (gpio\_esp32.hpp/.cpp) arbeitet dementsprechend mit \texttt{gpio\_config\_t} und \texttt{gpio\_set\_level} und \texttt{gpio\_get\_level} der ESP-IDF und setzt Entprellen mit \texttt{esp\_timer\_get\_time()} um.

Die tatsächliche Hardwarekonfiguration geschieht bewusst nicht im Konstruktor, sondern in der expliziten Methode \texttt{gpio\_init()}; ein Destruktor zur Deinitialisierung ist nicht vorgesehen.
Dadurch bleibt das Objekt leichtgewichtig, die Kontrolle über den Initialisierugn-Zeitpunkt liegt bei der aufrufenden Schicht.
\\
\\
Die STM32-Implementierung (spi\_stm32.hpp/.cpp) kapselt neben den Konfigurationsparametern auch die beteiligten GPIO-Objekte (SCK, MISO, MOSI, CS) per Komposition. 
Im Konstruktor werden auch hier, ähnlich der Gpio Klasse und in späteren Klassen, ausschließlich die Parameter übernommen. 
Die Aktivierung des jeweiligen SPI-Takts geschieht über eine automatische Instanzerkennung.
Die GPIO-Initialisierungen geschieht über die \texttt{gpio\_init()}; 
die Befüllung des \texttt{SPI\_HandleTypeDef}  erfolgt über Spi-spezifische Hilfsfunktion, wie \texttt{spiModeToHAL()}, \texttt{spiDataSizeToHAL()}, \texttt{spiClockPhaseToHAL()}). 
Diese arbeiten gleich wie die Hilfsfunktionen der Gpio-Klasse.
Dieser Initialisierungsprozess ist in der Methode \texttt{spi\_init()} gekapselt und folgt einem an die STM32CubeIDE angelehnten Ablauf.
Für Datentransfers stehen blockierende Varianten der entsprechenden Funktionen bereit: \texttt{transmit(), receive()} und \texttt{transmitReceive()}.% sowie DMA-basierte Wege bereit.
Die weiteren Varianten der Transferfunktionen mit Interrupt und DMA-Verhalten werden in der weiteren Entwicklung implementiert.
Für die Option \texttt{transmit\_DMA()} steht die Klasse Dma (dma\_stm32.hpp/.cpp) bereit.
Um eine Verbindung des SPI-Objektes mit einem DMA-Objekt zu schaffen, werden die Funktionen \texttt{setSpiHandle()} der DMA-Klasse und \texttt{set\_dma()} der SPI-Klasse verwendet.
Dabei bekommt \texttt{setSpiHandle()} den Handle des SPI-Objekts übergeben.
Mit \texttt{set\_dma()} und der übergebenen Adresse des DMA-Objektes (\texttt{\&dmaObjekt}), wird dieses im SPI-Objekt registriert.
Schlussendlich wird während der Initialisierung des DMA-Objektes, die genau so abläuft wie bei SPI und GPIO mit der jeweiligen Befüllung der Initalilisierungstrukturen, werden SPI und DMA via \texttt{\_\_HAL\_LINKDMA} verbunden.
Zudem werden NVIC-Prioritäten (Nested Vectored Interrupt Controller) gesetzt und Interrupts aktiviert.
Mittels der Abfragen \texttt{isDmaTransferInProgress()} und \texttt{abortDmaTransfer()} ist es möglich, den Status zu kontrollieren und die Logik des Abbruchs zu implementieren.
Es ist zu berücksichtigen, dass die Initialisierung in diesem Fall explizit über \texttt{dma\_init(), dma\_init\_TX()} und \texttt{dma\_init\_RX()} erfolgt, während die Destruktoren keine Aufräumfunktion übernehmen.
Diese Umsetzung zeichnet sich durch klare, definierte Lebenszyklen und Zustandsprüfungen aus, anstatt eine automatische Freigabe zu ermöglichen.

\vspace{0.5em}
\noindent\rule{\linewidth}{0.4pt}
\vspace{0.5em}

Die Analyse der Architektur verdeutlicht mehrere zentrale Gestaltungsprinzipien, die eine robuste und plattformübergreifende Hardware-Abstraktionsschicht ermöglichen. 
Im Vordergrund steht die konsequente Trennung von abstrakten Schnittstellen und konkreten Implementierungen. 
Schnittstellen, wie beispielsweise HardwareInterface, IGpioBase oder ISpi, definieren den plattformneutralen Zugriff. 
Die hardwarespezifische Realisierung wird hingegen durch Implementierungen wie Stm32c0xx\_hw oder GpioStm32 übernommen.
Dies führt zu einer klaren Trennung der Verantwortlichkeiten (Separation of Concerns), was wiederum die Portabilität und Wiederverwendbarkeit der Komponenten fördert.
Ein wesentliches Charakteristikum stellt die bewusste Entscheidung zugunsten expliziter Initialisierungsmethoden dar. 
Anstelle einer vollständigen Umsetzung des RAII-Paradigmas (Resource Acquisition Is Initialization) werden Methoden wie init\_sys(), gpio\_init() oder spi\_init() bereitgestellt. 
Diese Vorgehensweise erlaubt eine präzise Steuerung des Initialisierungszeitpunkts sowie der Reihenfolge der Hardwarekonfiguration, was insbesondere in ressourcenbeschränkten Embedded-Systemen mit engen Abhängigkeiten zwischen einzelnen Subsystemen von erheblicher Relevanz ist.

Zur Gewährleistung einer typsicheren und stabilen Schnittstelle kommen stark typisierte Enumerationen (enum class) in den Dateien hw\_enum\_*.hpp zum Einsatz. 
Diese Konstruktion fungiert als semantische Brücke zwischen plattformneutraler API und hardwarespezifischen Konstanten, wodurch Fehlkonfigurationen zur Compile-Zeit erkannt und inkonsistente Zustände vermieden werden können. 
Ergänzend tragen Factory-Singletons und klar definierte Besitzverhältnisse, wie etwa die Referenzierung von GPIO-Pins innerhalb der SPI-Klasse, zu deterministischen Objektlebenszyklen und einem vorhersagbaren Ressourcenmanagement bei.

Ein weiteres Gestaltungsprinzip ist die Bevorzugung von Komposition gegenüber Vererbung. 
Durch die kompositorische Struktur, wie beispielsweise in der Methode initAllPins(), wird eine lose Kopplung zwischen den Komponenten erzielt. 
Diese Vorgehensweise erleichtert nicht nur die Anpassung an neue Hardwareplattformen, sondern verbessert zugleich die Testbarkeit und Erweiterbarkeit der Architektur.

Besonders hervorzuheben ist die Entscheidung für ein Konzept des partiellen RAII. 
In klassischen Softwarearchitekturen wird RAII eingesetzt, um Ressourcen automatisch im Destruktor freizugeben. 
Im Embedded-Kontext kann diese Vorgehensweise jedoch unerwünschte Seiteneffekte hervorrufen, etwa durch nicht-deterministische Zeitpunkte der Ressourcenfreigabe. 
Die bewusste Vermeidung von versteckter Destruktor-Logik erlaubt eine explizite Kontrolle über die Lebenszyklen von Hardware-Ressourcen und minimiert das Risiko von Timing-Problemen oder nicht reproduzierbaren Zuständen.

Insgesamt verbindet die gewählte Designphilosophie moderne Prinzipien der C++-Programmierung, wie starke Typisierung, deterministische Lebenszyklusverwaltung und modulare Abstraktion mit den praktischen Erfordernissen der Embedded-Entwicklung. 
Das Resultat ist eine klar strukturierte, plattformübergreifende Abstraktionsschicht, die sowohl Effizienz als auch Wartbarkeit sicherstellt und damit eine tragfähige Grundlage für zukünftige Erweiterungen bildet.



































