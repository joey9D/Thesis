%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Notizen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notizen}
Ähnlich zu dem Projekt mcu-cpp soll die eigene Lösung auch Interfaces bzw. virtuelle Klassen als Basis verwenden, die dann von allen MCUs abstrahiert werden können.
Auf diese Weise bekommt jede MCU eine eigene Kindklasse, über die die richtigen Treiber ausgewählt werden.



\begin{itemize}
	\item Interface/virtuelle Klassen als Basis
	\item \textbf{Factory Methode} zur Erzeugung der Objekte $\rightarrow$ Entwurf der Architektur
	\item [$\Rightarrow$] Adapter implementieren um andere MCUs verwenden.
	\item [$\Rightarrow$] Was muss alles bedacht werden:
	\begin{itemize}
		\item Pin Initialisierung $\rightarrow$ STM32 ok; wie bei anderen MCUs?
		\item Interrupt-Handling
		\item 
		\item Flashen des Chips mit dem Programm
	\end{itemize}
	\item einfache Make commands rufen CMake build commands auf
	\item Ninja als Generator $\rightarrow$ wird von ESP, mcu-cpp, Zephyr schon benutzt. STM32 nutzt make, kann aber getauscht/angepasst/konfiguriert werden
	\item Treiber (HAL, vllt. CMSIS) als Submodule
\end{itemize}

\subsection{Architektur}
\subsubsection*{Factory}
\begin{itemize}
	\item erstellt und returned Hardware-Instanz
	\item für HW-Inistialisierung
	\item erstellt Instanz je nach Hardware $\rightarrow$ \texttt{\#ifdef}
\end{itemize}

\subsubsection*{Peripherie: GPIO, SPI, UART}
\begin{itemize}
	\item eigene Klasse
	\item erstmal für STM32 $\rightarrow$ danach Adapter für andere?
\end{itemize}

Keine \texttt{setter}
\begin{itemize}
	\item Pin wird nur einmal initialisiert
	\item normalerweise keine nachträgliche Änderungen zur Laufzeit
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PROBLEME
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Probleme:}
\begin{itemize}
	\item Interruptfunktionen $\rightarrow$ werden automatische aufgerufen und nicht vom Entwickler. Wenn ein Interrupt auftritt wird der Rest der HAL \& der MCU informiert.\\ \textbf{Frage:} Wie kann es umgesetzt werden, dass das GPIO-Objekt der API und der Code der Anwendungsschicht aus der HAL und den Registern über einen Interrupt informiert werden?
	\item \texttt{\_\_HAL\_RCC\_GPIOA\_CLK\_ENABLE()} setzt den Pin im Inputregister IDR $\rightarrow$ ID14.
	
\end{itemize}

\subsection*{Gelöst}
\begin{itemize}
	\item GPIO init $\rightarrow$ MX\_GPIO\_Init() startet mit \texttt{iocurrent} bei $0$. Mit dem Aufruf durch das Objekt startet \texttt{iocurrent} auf etwas extrem Hohen. \\ $\Longrightarrow$ Ist Egal. \texttt{iocurrent} bekommt direkt einen richtigen Startwert zugewiesen.
	\item Statt \texttt{ID15} für Pin 15 zu wechseln, werden die \texttt{ID0-3} gewechselt. Diese ersten $4$ Pin ergeben binär auch $15\ =\ 1111\ =\ 1*2^3\ +\ 1*2^2\ +\ 1*2^1\ +\ 1*2^0$ \\ \textbf{Lösung:} Nicht den Wert $15$ dem Pin Attribut geben sondern am Bit $15$, dass diese Bit dann auf $1$ gesetzt wird.
	\item Wenn die LED an ist, d.h. wenn der Pin gesetzt ist, verändert sich der Pin des Tasters, ohne dass dieser betätigt wurde. Wieso?\\ \textbf{Beobachtung:} Ob bei \texttt{readPin()} Register ID$14$ oder ID$9$ verwendet wird (es sollte $9$ sein; $14$ ist nur im Debugger aktiv und für uns uninteressant) schon zufällig zu sein.\\ \textbf{Lösung:} Mit Pin-Debouncing und Implementierung einer Timer-Klasse konnte das zufällige Verhalten gelöst werden. 
	\item Mit \texttt{time.hpp} und \texttt{stm32::Gpio::Pull::Up} funktioniert die Schaltung.\\ \textbf{Frage:} Wieso funktioniert das mit \texttt{Pull::Up} und nicht mit \texttt{Pull::None} od. \texttt{Pull::Down}?\\ \textbf{Antwort:} Mit \texttt{Pull::None} befindet sich der Schalter in einem \emph{float} Zustand. In diesem werden besonders Einflüsse der Umwelt, sog. Noise/Rauschen aufgenommen, die das Verhalten der Schaltung unberechenbar machen. Dieses zufällige Verhalten sollte vermieden werden, besonders in einem sicherheitskritischen Umfeld.
\end{itemize}

\vspace{3mm}

mapping $\rightarrow$ stm32c0xx.h $\rightarrow$ stm32c031xx.h mit allen TypeDefs $\rightarrow$ system\_stm32c031xx.h

$\Longrightarrow$ include Fehler: statt nur stm32\_hal\_gpio.h, besser stm32\_hal.h einbinden.
\\

Verwendung von STM32CubeIDE für bessere Übersicht beim Debuggen über die Register.
\\
